<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ellcc | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/ellcc/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2015-06-09T16:04:33-07:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[RobertN]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ellcc.org Build Fix for OS-X]]></title>
    <link href="http://sushihangover.github.io/ellcc-dot-org-build-fix-for-os-x/"/>
    <updated>2014-02-12T00:00:00-08:00</updated>
    <id>http://sushihangover.github.io/ellcc-dot-org-build-fix-for-os-x</id>
    <content type="html"><![CDATA[<p>In my ARM Bare Metal searches for using Clang/LLVM I stumbled across <a href="http://ellcc.org">The ELLCC Embedded Compiler Collection</a> that provides a one-stop build enviroment for all the LLVM tools for cross-platform compiling.</p>

<p>I&rsquo;m not sure if they are trying to be a <a href="http://yagarto.org">YAGARTO</a> for LLVM vs. GCC. I waiting for a reply to post on their forum to understand the actual code changes to Clang/LLVM that they include (if any). <del>I will update when I hear back.</del> <strong>(Update: Read Rich&rsquo;s <a href="http://ellcc.org/blog/?topic=ellcc-vs-clangllvm-trunk/#post-1571">full reply</a>, it cleared everything up for me)</strong></p>

<p>{% blockquote Rich <a href="http://ellcc.org/blog/?topic=ellcc-vs-clangllvm-trunk/#post-1571">http://ellcc.org/blog/?topic=ellcc-vs-clangllvm-trunk/#post-1571</a> What is ELLCC all about %}
ELLCC is really just a weekly repackaging of clang/LLVM with two minor additions.
1. The triples of the form -ellcc- (where OS is linux for now, but will include others eventually) control how include files and libraries are found. You might notice for example that the #include path for ELLCC&hellip;
{% endblockquote %}</p>

<p>But in the mean time I figured I give it a build and include it in my GCC/ARM vs. Clang/LLVM-ARM testing but hit a build error on OS-X. On the linking of QEMU, libintl (GNU&rsquo;s gettext) is not found:</p>

<pre><code>LINK  i386-softmmu/qemu-system-i386
ld: library not found for -lintl
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[1]: *** [qemu-system-i386] Error 1
make: *** [subdir-i386-softmmu] Error 2
</code></pre>

<p>I do have gettext on my system, but it is in my &ldquo;Cellar&rdquo;&ldquo; as I use <a href="http://brew.sh">HomeBrew</a> as my package manager and try not to install anything to &rdquo;/usr/bin" or other systems places that can muck everything up and thus can run parrallels versions of different applications (i.e. If I have to &lsquo;sudo&rsquo; to an open-source software install, it is not going on my system unless they have a serious reason for it and I trust the code from a security viewpoint).</p>

<p>FYI: Brew does not &lsquo;hard&rsquo; link gettext as compiling software outside of the HomeBrew can cause problems:</p>

<p>{% blockquote %}
brew link gettext
Warning: gettext is keg-only and must be linked with &ndash;force
Note that doing so can interfere with building software.
{% endblockquote %}</p>

<p>So I mod&rsquo;d the &ldquo;ellcc/gnu/build&rdquo; to force brew to link gettext before compiling/linking qemu and unlink it after.</p>

<p>{% codeblock lang:bash %}
svn diff build</p>

<h1>Index: build</h1>

<p>&mdash; build   (revision 3780)
+++ build   (working copy)
@@ -69,6 +69,10 @@
     ppc-linux-user ppc64-linux-user ppc64abi32-linux-user sparc-linux-user"
 fi
 echo Configuring package qemu for $targets
+if [!  -e <code>which brew</code> ]; then
+   ruby -e &ldquo;$(curl -fsSL <a href="https://raw.github.com/Homebrew/homebrew/go/install">https://raw.github.com/Homebrew/homebrew/go/install</a>)&rdquo;
+fi
+brew link gettext &ndash;force
 qemu_target_list=<code>echo $qemu_target_list | sed -e "s/ /,/g"</code>
 make DIR=src/qemu CC=$cc HCC=$hcc AR=$ar TARGET=$host OS=$os \
     targetlist=$qemu_target_list haslibs=$haslibs \
@@ -76,6 +80,7 @@
     qemu.configure || exit 1</p>

<p> make -C src/qemu || exit 1
+brew unlink gettext</p>

<p> # Finally, install into the target specific bin dir.
 mkdir -p $bindir
{% endcodeblock %}</p>

<p>Everything builds fine after that&hellip;</p>

<p>The entire file is here:
{% gist 8949755 %}</p>
]]></content>
  </entry>
  
</feed>
