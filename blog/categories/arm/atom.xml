<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ARM | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/arm/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2014-02-19T22:34:47-08:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[Robert N.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LLVM ARM Triple CPU Targets]]></title>
    <link href="http://sushihangover.github.io/llvm-arm-triple-cpu-targets"/>
    <updated>2014-02-19T06:36:42-08:00</updated>
    <id>http://sushihangover.github.io/llvm-arm-triple-cpu-targets</id>
    <content type="html"><![CDATA[<p>I am building a bare-metal ARM Clang/LLVM cross-compiler for my Arm Cortex-M LLVM vs. arm-gcc experiments and was looking for the complete ARM core list available.</p>

<p>LLVM makes it soooo easy to get that information from the LLVM static compiler binary (<a href="http://llvm.org/docs/CommandGuide/llc.html">llc</a>), just pass it a generic ARM triple, here is the lsit from my build:
<code>
llc -mtriple=arm-none-eabi -mcpu=help
</code>
```
Available CPUs for this target:</p>

<p>  arm1020e      &ndash; Select the arm1020e processor.
  arm1020t      &ndash; Select the arm1020t processor.
  arm1022e      &ndash; Select the arm1022e processor.
  arm10e        &ndash; Select the arm10e processor.
  arm10tdmi     &ndash; Select the arm10tdmi processor.
  arm1136j-s    &ndash; Select the arm1136j-s processor.
  arm1136jf-s   &ndash; Select the arm1136jf-s processor.
  arm1156t2-s   &ndash; Select the arm1156t2-s processor.
  arm1156t2f-s  &ndash; Select the arm1156t2f-s processor.
  arm1176jz-s   &ndash; Select the arm1176jz-s processor.
  arm1176jzf-s  &ndash; Select the arm1176jzf-s processor.
  arm710t       &ndash; Select the arm710t processor.
  arm720t       &ndash; Select the arm720t processor.
  arm7tdmi      &ndash; Select the arm7tdmi processor.
  arm7tdmi-s    &ndash; Select the arm7tdmi-s processor.
  arm8          &ndash; Select the arm8 processor.
  arm810        &ndash; Select the arm810 processor.
  arm9          &ndash; Select the arm9 processor.
  arm920        &ndash; Select the arm920 processor.
  arm920t       &ndash; Select the arm920t processor.
  arm922t       &ndash; Select the arm922t processor.
  arm926ej-s    &ndash; Select the arm926ej-s processor.
  arm940t       &ndash; Select the arm940t processor.
  arm946e-s     &ndash; Select the arm946e-s processor.
  arm966e-s     &ndash; Select the arm966e-s processor.
  arm968e-s     &ndash; Select the arm968e-s processor.
  arm9e         &ndash; Select the arm9e processor.
  arm9tdmi      &ndash; Select the arm9tdmi processor.
  cortex-a12    &ndash; Select the cortex-a12 processor.
  cortex-a15    &ndash; Select the cortex-a15 processor.
  cortex-a5     &ndash; Select the cortex-a5 processor.
  cortex-a53    &ndash; Select the cortex-a53 processor.
  cortex-a57    &ndash; Select the cortex-a57 processor.
  cortex-a7     &ndash; Select the cortex-a7 processor.
  cortex-a8     &ndash; Select the cortex-a8 processor.
  cortex-a9     &ndash; Select the cortex-a9 processor.
  cortex-a9-mp  &ndash; Select the cortex-a9-mp processor.
  cortex-m0     &ndash; Select the cortex-m0 processor.
  cortex-m3     &ndash; Select the cortex-m3 processor.
  cortex-m4     &ndash; Select the cortex-m4 processor.
  cortex-r5     &ndash; Select the cortex-r5 processor.
  ep9312        &ndash; Select the ep9312 processor.
  generic       &ndash; Select the generic processor.
  iwmmxt        &ndash; Select the iwmmxt processor.
  krait         &ndash; Select the krait processor.
  mpcore        &ndash; Select the mpcore processor.
  mpcorenovfp   &ndash; Select the mpcorenovfp processor.
  strongarm     &ndash; Select the strongarm processor.
  strongarm110  &ndash; Select the strongarm110 processor.
  strongarm1100 &ndash; Select the strongarm1100 processor.
  strongarm1110 &ndash; Select the strongarm1110 processor.
  swift         &ndash; Select the swift processor.
  xscale        &ndash; Select the xscale processor.
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM Cortex-M0 Overview]]></title>
    <link href="http://sushihangover.github.io/arm-cortex-m0-overview"/>
    <updated>2014-02-17T06:02:25-08:00</updated>
    <id>http://sushihangover.github.io/arm-cortex-m0-overview</id>
    <content type="html"><![CDATA[<p>ARM Cortex-M0 Overview By: Daniel Widyanto September 2010</p>

<p  style=" margin: 12px auto 6px auto; font-family: Helvetica,Arial,Sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 14px; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none; display: block;">   <a title="View ARM Cortex-M0 Overview on Scribd" href="http://www.scribd.com/doc/38226967"  style="text-decoration: underline;" >ARM Cortex-M0 Overview</a></p>


<iframe class="scribd_iframe_embed" src="http://sushihangover.github.io//www.scribd.com/embeds/38226967/content?start_page=1&view_mode=scroll&show_recommendations=true" data-auto-height="false" data-aspect-ratio="undefined" scrolling="no" id="doc_32615" width="100%" height="600" frameborder="0"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bare Metal ARM Terminology]]></title>
    <link href="http://sushihangover.github.io/bare-metal-arm-terminology"/>
    <updated>2014-02-16T21:35:45-08:00</updated>
    <id>http://sushihangover.github.io/bare-metal-arm-terminology</id>
    <content type="html"><![CDATA[<p><a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS</a> : ARM® <strong>C</strong>ortex™ <strong>M</strong>icrocontroller <strong>S</strong>oftware <strong>I</strong>nterface <strong>S</strong>tandard</p>

<p>Thread mode :</p>

<blockquote><p>Used to execute application software. The processor enters Thread mode when it comes out of reset.</p></blockquote>

<p>Privileged or unprivileged software execution :</p>

<blockquote><p>Cortex-M0 do not support different privilege levels. Software execution is always privileged; i.e. Software can access all the features of the processor. Other ARM series do support pri and unpri execution.</p></blockquote>

<p>Handler mode :</p>

<blockquote><p>Used to handle exceptions. The processor returns to Thread mode when it has finished all exception processing</p></blockquote>

<p>SysTick : A 24-bit count-down timer.</p>

<blockquote><p>This timer is the basis for a <em>ticktimer</em> for an embedded Real Time Operating System (RTOS) like FreeRTOS. And, yes, it can be used as a simple counter.</p></blockquote>

<p>System Control Block :</p>

<blockquote><p>Provides system implementation information and system control, including configuration, control,and reporting of system exceptions.</p></blockquote>

<p>NVIC : Nested Vectored Interrupt Controller</p>

<blockquote><p>In the Cortex-M0, Cortex-M0+ and Cortex-M1 processors, the NVIC support up to 32 interrupts (IRQ), a Non-Maskable Interrupt (NMI) and various system exceptions, other M series, like M3/M4, can support up to 240 IRQs.
Tail chaining > If another exception is pending when an ISR exits, the processor does not restore all saved registers from the stack and instead moves on to the next ISR. This reduces the latency when switching from one exception handler to another.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Is Bare Metal ARM]]></title>
    <link href="http://sushihangover.github.io/what-is-bare-metal-arm"/>
    <updated>2014-02-16T08:12:02-08:00</updated>
    <id>http://sushihangover.github.io/what-is-bare-metal-arm</id>
    <content type="html"><![CDATA[<h2>What is Bare Metal ARM Development?</h2>

<blockquote><p>Bare-Metal ARM Development, also called <a href="http://en.wikipedia.org/wiki/Bare_machine">Bare-Machine</a> is the development of &lsquo;embedded&rsquo; applications, that run without an operating system or other supporting programs, maybe a bootloader, on an ARM processor. The application sits on top of the “bare metal”, runs ARM instructions (including THUMB), directly controls the processor (MCU) to manage power consumption, GPIOs, ADC, DAC, etc&hellip;</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Embedded 'Bare-Metal' ARM Development - Part 1]]></title>
    <link href="http://sushihangover.github.io/embedded-bare-metal-arm-development-part-1"/>
    <updated>2014-02-14T06:01:48-08:00</updated>
    <id>http://sushihangover.github.io/embedded-bare-metal-arm-development-part-1</id>
    <content type="html"><![CDATA[<p>This is a start of a series of posts related to getting into ARM-based Cortex core programming. So I started on a quest to checkout ARM Embedded &lsquo;Bare-Metal&rsquo; compilers and tools and in the end(?) cleared up my confusion about what I can and can not do on a restricted budget and time.</p>

<p>The reasoning behind this is I wanted to do some bare metal ARM C coding for a project that might become some type of OSHW or even a commerical offering so I wanted to keep my options open, try to future proof my decisions.</p>

<p>Instead of falling back to my comfort zone with AVR 8-bit MCU C-codings and forcing a project that really is beyond what AVRs offer (mainly execution speed and size related plus I tired of all the bit-banging to &lsquo;add&rsquo; protocals) and the fact that ARM-based core offerings that are now available have not just tons of digital GPIOs, footprints that are as small, but also have great signal processing options (input and output) that can match or exceed what is available in Amtel&rsquo;s AVR 8-bit line up and<strong> match them at price.</strong></p>

<p>Just compare the Atmel AVR line up to their D20 ARM-core offerings and for non-legacy new embedded projects the decision matrix might be almost equal, but if you are adding &lsquo;future-proofing&rsquo; to the mix and what MCUs will be offering in the next decade, ARM-based MCUs become a clear choice (would love to hear someone&rsquo;s counter-point!).</p>

<p>So first I figured I look at ARM compilers/linkers as if you can not compile/link your code, than you are just screwed ;&ndash;) So in terms of ARM compilers available there <strong>is</strong> more than one:</p>

<ul>
<li><a href="https://launchpad.net/gcc-arm-embedded">GNU C Compiler</a>(1)</li>
<li><a href="http://www.freescale.com/codewarrior">CodeWarrior</a> ARM C Compiler(2)</li>
<li><a href="http://www.iar.com">IAR</a> ARM C Compiler</li>
<li><a href="https://www.imagecraft.com">ImageCraft</a> C Compiler Tools</li>
<li><a href="http://www.keil.com">Kiel</a> ARM C/C++ Compiler(3)</li>
<li><a href="http://ds.arm.com">ARM DS-5</a> RealView C/C++ Compiler(3)</li>
<li>ARM <a href="http://clang.llvm.org">Clang</a>/<a href="http://llvm.org">LLVM</a> Compiler</li>
<li>Microsoft Visual Studio C/C++ Native ARM Compiler(4)</li>
</ul>


<h6>* 1: Technically the launchpad link is the &lsquo;output&rsquo; of an ARM version of GCC and binutils but is the best starting point for info on the ARM version as it is the offical distro end-point ;&ndash;)</h6>

<p><blockquote><p>ARM employees are maintaining this project. Contributing to this project should be via GCC trunk <a href="http://gcc.gnu.org">http://gcc.gnu.org</a> and binutils trunk <a href="http://www.gnu.org/software/binutils/.">http://www.gnu.org/software/binutils/.</a> This launchpad project is for communication and downloading. No code change is done in lp project.</p></blockquote></p>

<h6>* 2: The &lsquo;Freescale Kinetis Compiler&rsquo; is in maintance mode. The GNU compiler is the &lsquo;active&rsquo; mainline of ARM compiler within CodeWarror now and thus I am not looking at this one at all as it fails my future proofing rules. For existing &lsquo;legacy&rsquo; embedded projects based on it, <a href="http://en.wikipedia.org/wiki/CodeWarrior">MetroWorks</a> was acquired by Motorola which was then included in the Freescale spinoff, so go to Freescale if you need a version&hellip;</h6>

<h6>* 3: ARM acquired Kiel and thus the compiler IP from the two is now within one toolchain simply called &ldquo;ARM Compiler toolchain&rdquo; and thus RealView no longer exists, but some old-timers ;&ndash;) still call the new version by the RealView name. Note: There are still different development IDEs from each company; Kiel has uVision and ARM has Eclipse intergation (via a standalone version or plugins for your existing install), but again, they use just the &lsquo;new&rsquo; version of the compiler, but more on the IDEs in a future post of this series.</h6>

<h6>* 4: Yes, you can produce ARM code as you would have to in order to cross-compile Windows RT apps, but can you do bare metal programming with it? I am not sure if you can get a CMSIS setup using it and handle the .S/SystemInit/Reset_Handler/__main() of bare metal programming&hellip;</h6>

<h6>* If I missed one, please let me know!.</h6>

<p>So an ARM compiler choice is not as easy as just saying GNU/GCC as you have other options and while in the end they all produce an ELF/BIN that you flash on your bare-metal ARM, how that binary gets created and the size and speed of the ARM code and/or THUMB instructions that was produced can vary greatly&hellip;</p>

<p>Next time, we look into some compilers&hellip;</p>
]]></content>
  </entry>
  
</feed>
