<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ARM | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/arm/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2014-02-23T01:08:46-08:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[Robert N.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARM Bare Metal Hello World: Comparing LLVM & ARM-GCC]]></title>
    <link href="http://sushihangover.github.io/arm-bare-metal-comparing-llvm-to-arm-gcc"/>
    <updated>2014-02-22T20:43:28-08:00</updated>
    <id>http://sushihangover.github.io/arm-bare-metal-comparing-llvm-to-arm-gcc</id>
    <content type="html"><![CDATA[<p>With the ever maturing and stable ARM backend of LLVM it is hard to find information using it vs. the well known ARM-GCC release.</p>

<p>So lets start with the most simple HelloWorld example and compare LLVM and <a href="https://launchpad.net/gcc-arm-embedded">ARM-GCC</a>.</p>

<p><a href="http://balau82.wordpress.com/2010/02/28/hello-world-for-bare-metal-arm-using-qemu/">Balau&rsquo;s post</a> is a popular one showing an ARM bare metal Hello World and test using QEMU, so lets start with that one. First, lets reproduce the compile/link steps to make sure it works:</p>

<p><code>
arm-none-eabi-as -mcpu=arm926ej-s src/startup.s -o obj/startup.o
arm-none-eabi-gcc -c -mcpu=arm926ej-s -O0 src/HelloWorldSimple.c -o obj/HelloWorldSimple.o
arm-none-eabi-ld -T src/HelloWorldSimple.ld obj/HelloWorldSimple.o obj/startup.o -o bin/HelloWorldSimple.axf_gcc
arm-none-eabi-size bin/HelloWorldSimple.axf_gcc
qemu-system-arm -M versatilepb -m 128M -nographic -kernel bin/HelloWorldSimple.axf_gcc
Hello world!
QEMU: Terminated
</code>
Works just fine, so lets reproduce that using   my <a href="https://github.com/sushihangover/llvm_baremetal">LLVM bare metal build</a>. All the compiler options are being shown even though some are defaulted in my build of LLVM so you can see everything it is required to get the LLVM bitcode conversion to produce a valid object file for our ARM target (I&rsquo;m using the Clang driver, but you can use LLVM and pipe bitcode through the various tools so you can deeply control the optimization phase):
<code>
clang -c -target arm-none-eabi -mcpu=arm926ej-s -O0 -mfloat-abi=soft -g startup.s -o startup.o
clang -c -target arm-none-eabi -mcpu=arm926ej-s -O0 -mfloat-abi=soft -g HelloWorldSimple.c -o main.o
arm-none-eabi-ld -T HelloWorldSimple.ld main.o startup.o -o main.axf_llvm
qemu-system-arm -M versatilepb -m 128M -nographic -kernel main.axf_llvm
Hello world!
QEMU: Terminated
</code>
* target : Option providing the triple that you are &lsquo;targeting&rsquo;
* mpcu : Option provding the ARM core that will be flashed
* mfloat-abi : Soft or Hard depending upon if your ARM core has an FPU implementation on it. Cores that can support an FPU does not mean your vendor&rsquo;s core has one, comes down to features/price of the core.</p>

<h6>Note: In both, I am turning off the optimizers via the compile drivers.</h6>

<p>Lets look at the size of the AXF (ARM Executable Format) produced by:</p>

<p>```
   text    data     bss     dec     hex filename</p>

<pre><code>140       0       0     140      8c bin/HelloWorldSimple.axf_gcc
</code></pre>

<p>   text    data     bss     dec     hex filename</p>

<pre><code>150       0       0     150      96 bin/HelloWorldSimple.axf
</code></pre>

<p>```
There is a 10 byte difference, interesting&hellip; lets look at that a little more:</p>

<table>
<thead>
<tr>
<th></th>
<th> llvm </th>
<th></th>
<th></th>
<th> arm-gcc </th>
<th> </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> section  </td>
<td> size </td>
<td> addr</td>
<td>section </td>
<td>size</td>
<td> addr</td>
</tr>
<tr>
<td></td>
<td>.startup  </td>
<td>16</td>
<td>   65536</td>
<td>.startup </td>
<td> 16 </td>
<td>65536</td>
</tr>
<tr>
<td></td>
<td>.text </td>
<td>             108 </td>
<td>  65552</td>
<td>.text              </td>
<td>104   </td>
<td>65552</td>
</tr>
<tr>
<td></td>
<td>.ARM.exidx</td>
<td>           8 </td>
<td>  65660</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>.rodata   </td>
<td>           4 </td>
<td>  65668</td>
<td>.rodata  </td>
<td>           20  </td>
<td> 65656</td>
</tr>
<tr>
<td></td>
<td>.rodata.str1.1</td>
<td>      14 </td>
<td>  65672</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>.ARM.attributes</td>
<td>     40 </td>
<td>      0</td>
<td>.ARM.attributes </td>
<td>    46 </td>
<td>      0</td>
</tr>
<tr>
<td></td>
<td>.comment       </td>
<td>     19 </td>
<td>      0</td>
<td>.comment  </td>
<td>         112  </td>
<td>     0</td>
</tr>
<tr>
<td></td>
<td>Total          </td>
<td>    209</td>
<td></td>
<td>Total              </td>
<td>298</td>
<td></td>
</tr>
</tbody>
</table>


<h6>Note: I ran strip on the arm-gcc version to remove the empty debug sections that gcc inserts automatically</h6>

<p>The <strong>.startup</strong> are the same size since this code is assembly and no codegen or optimization will happen there.</p>

<p>It is interesting that LLVM inserts a <strong>.ARM.exidx</strong> section even though this is <em>only</em> .c code. I&rsquo;ll have to look at LLVM to see if <em>-funwind-tables</em> and/or <em>-fexceptions</em> are defaulted to on, but I disassemble it below so we can look at that as that is 8 bytes and accounts for the size difference in this really basic example.</p>

<blockquote><p>.ARM.exidx is the section containing information for unwinding the stack</p></blockquote>

<h6>Note: Understanding the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044e/IHI0044E_aaelf.pdf">ARM ELF format</a> is not really required to do bare metal programming, but, understanding how your code is allocated and loaded can maek a world of differences when you are writting linker definitions files for different cores, so send a few minutes and read the 46 pages :&ndash;)</h6>

<p>First the gcc disassembly so we can compare the LLVM version to it:
<code>
bin/HelloWorldSimple.axf_gcc:     file format elf32-littlearm
Disassembly of section .startup:
00010000 &lt;_Reset&gt;:
   10000:   e59fd004    ldr sp, [pc, #4]    ; 1000c &lt;_Reset+0xc&gt;
   10004:   eb000015    bl  10060 &lt;c_entry&gt;
   10008:   eafffffe    b   10008 &lt;_Reset+0x8&gt;
   1000c:   00011090    .word   0x00011090
Disassembly of section .text:
00010010 &lt;print_uart0&gt;:
   10010:   e52db004    push    {fp}        ; (str fp, [sp, #-4]!)
   10014:   e28db000    add fp, sp, #0
   10018:   e24dd00c    sub sp, sp, #12
   1001c:   e50b0008    str r0, [fp, #-8]
   10020:   ea000006    b   10040 &lt;print_uart0+0x30&gt;
   10024:   e59f3030    ldr r3, [pc, #48]   ; 1005c &lt;print_uart0+0x4c&gt;
   10028:   e51b2008    ldr r2, [fp, #-8]
   1002c:   e5d22000    ldrb    r2, [r2]
   10030:   e5832000    str r2, [r3]
   10034:   e51b3008    ldr r3, [fp, #-8]
   10038:   e2833001    add r3, r3, #1
   1003c:   e50b3008    str r3, [fp, #-8]
   10040:   e51b3008    ldr r3, [fp, #-8]
   10044:   e5d33000    ldrb    r3, [r3]
   10048:   e3530000    cmp r3, #0
   1004c:   1afffff4    bne 10024 &lt;print_uart0+0x14&gt;
   10050:   e24bd000    sub sp, fp, #0
   10054:   e49db004    pop {fp}        ; (ldr fp, [sp], #4)
   10058:   e12fff1e    bx  lr
   1005c:   101f1000    .word   0x101f1000
00010060 &lt;c_entry&gt;:
   10060:   e92d4800    push    {fp, lr}
   10064:   e28db004    add fp, sp, #4
   10068:   e59f0004    ldr r0, [pc, #4]    ; 10074 &lt;c_entry+0x14&gt;
   1006c:   ebffffe7    bl  10010 &lt;print_uart0&gt;
   10070:   e8bd8800    pop {fp, pc}
   10074:   0001007c    .word   0x0001007c
</code>
Now the LLVM version:
<code>
bin/HelloWorldSimple.axf:     file format elf32-littlearm
Disassembly of section .startup:
00010000 &lt;_Reset&gt;:
   10000:   e59fd004    ldr sp, [pc, #4]    ; 1000c &lt;_Reset+0xc&gt;
   10004:   eb000016    bl  10064 &lt;c_entry&gt;
   10008:   eafffffe    b   10008 &lt;_Reset+0x8&gt;
   1000c:   00011098    .word   0x00011098
Disassembly of section .text:
00010010 &lt;print_uart0&gt;:
   10010:   e24dd008    sub sp, sp, #8
   10014:   e1a01000    mov r1, r0
   10018:   e58d0004    str r0, [sp, #4]
   1001c:   e58d1000    str r1, [sp]
   10020:   e59d0004    ldr r0, [sp, #4]
   10024:   e5d00000    ldrb    r0, [r0]
   10028:   e3500000    cmp r0, #0
   1002c:   0a000009    beq 10058 &lt;print_uart0+0x48&gt;
   10030:   eaffffff    b   10034 &lt;print_uart0+0x24&gt;
   10034:   e59d0004    ldr r0, [sp, #4]
   10038:   e5d00000    ldrb    r0, [r0]
   1003c:   e59f101c    ldr r1, [pc, #28]   ; 10060 &lt;print_uart0+0x50&gt;
   10040:   e5911000    ldr r1, [r1]
   10044:   e5810000    str r0, [r1]
   10048:   e59d0004    ldr r0, [sp, #4]
   1004c:   e2800001    add r0, r0, #1
   10050:   e58d0004    str r0, [sp, #4]
   10054:   eafffff1    b   10020 &lt;print_uart0+0x10&gt;
   10058:   e28dd008    add sp, sp, #8
   1005c:   e12fff1e    bx  lr
   10060:   00010084    .word   0x00010084
00010064 &lt;c_entry&gt;:
   10064:   e92d4800    push    {fp, lr}
   10068:   e1a0b00d    mov fp, sp
   1006c:   e59f0004    ldr r0, [pc, #4]    ; 10078 &lt;c_entry+0x14&gt;
   10070:   ebffffe6    bl  10010 &lt;print_uart0&gt;
   10074:   e8bd8800    pop {fp, pc}
   10078:   00010088    .word   0x00010088
</code>
<a href="/images/llvm-gcc-diff_large.png"><img class="left" src="/images/llvm-gcc-diff_small.png" title="&ldquo;LLVM vs. GCC Hello World ARM Bare Metal&rdquo;" ></a> We can ignore the _Reset section as that is hand coded assembly and the same for both.</p>

<p>The c_entry is interesting as LLVM uses a move to copy the stack register to fp (r11 = frame pointer) which I what I would do, but arm-gcc does an &ldquo;"add&rdquo;&ldquo; to get fp into the sp and does that by adding fp to register #4(?) This is flagged as general variable for gcc&hellip; I am slightly confused by gcc&rsquo;s choice to do that, now that question is when would #4 not contain zero? The rest of this function is the same between the two compilers.</p>

<p>The print_uart0 function is a hack function as it does not implement FIFO/flow-control to an actual UART, but in this case it points to a memory address where the discontinued ARM Versatile PB dev-board does have a UART and QEMU board simulation echos those writes. I am not going to do a line by line comparision of the generated code as for un-optimized code they are both getting the job done, but in slightly different ways in almost the same number of instructions.</p>

<p>So we are able to produce a working bare metal ARM AXF from LLVM and next time, I will spend a little time on compiler optimizations to see how the two code generators/optimizisers compare&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LLVM ARM Triple CPU Targets]]></title>
    <link href="http://sushihangover.github.io/llvm-arm-triple-cpu-targets"/>
    <updated>2014-02-19T06:36:42-08:00</updated>
    <id>http://sushihangover.github.io/llvm-arm-triple-cpu-targets</id>
    <content type="html"><![CDATA[<p>I am building a bare-metal ARM Clang/LLVM cross-compiler for my Arm Cortex-M LLVM vs. arm-gcc experiments and was looking for the complete ARM core list available.</p>

<p>LLVM makes it soooo easy to get that information from the LLVM static compiler binary (<a href="http://llvm.org/docs/CommandGuide/llc.html">llc</a>), just pass it a generic ARM triple, here is the lsit from my build:
<code>
llc -mtriple=arm-none-eabi -mcpu=help
</code>
```
Available CPUs for this target:</p>

<p>  arm1020e      &ndash; Select the arm1020e processor.
  arm1020t      &ndash; Select the arm1020t processor.
  arm1022e      &ndash; Select the arm1022e processor.
  arm10e        &ndash; Select the arm10e processor.
  arm10tdmi     &ndash; Select the arm10tdmi processor.
  arm1136j-s    &ndash; Select the arm1136j-s processor.
  arm1136jf-s   &ndash; Select the arm1136jf-s processor.
  arm1156t2-s   &ndash; Select the arm1156t2-s processor.
  arm1156t2f-s  &ndash; Select the arm1156t2f-s processor.
  arm1176jz-s   &ndash; Select the arm1176jz-s processor.
  arm1176jzf-s  &ndash; Select the arm1176jzf-s processor.
  arm710t       &ndash; Select the arm710t processor.
  arm720t       &ndash; Select the arm720t processor.
  arm7tdmi      &ndash; Select the arm7tdmi processor.
  arm7tdmi-s    &ndash; Select the arm7tdmi-s processor.
  arm8          &ndash; Select the arm8 processor.
  arm810        &ndash; Select the arm810 processor.
  arm9          &ndash; Select the arm9 processor.
  arm920        &ndash; Select the arm920 processor.
  arm920t       &ndash; Select the arm920t processor.
  arm922t       &ndash; Select the arm922t processor.
  arm926ej-s    &ndash; Select the arm926ej-s processor.
  arm940t       &ndash; Select the arm940t processor.
  arm946e-s     &ndash; Select the arm946e-s processor.
  arm966e-s     &ndash; Select the arm966e-s processor.
  arm968e-s     &ndash; Select the arm968e-s processor.
  arm9e         &ndash; Select the arm9e processor.
  arm9tdmi      &ndash; Select the arm9tdmi processor.
  cortex-a12    &ndash; Select the cortex-a12 processor.
  cortex-a15    &ndash; Select the cortex-a15 processor.
  cortex-a5     &ndash; Select the cortex-a5 processor.
  cortex-a53    &ndash; Select the cortex-a53 processor.
  cortex-a57    &ndash; Select the cortex-a57 processor.
  cortex-a7     &ndash; Select the cortex-a7 processor.
  cortex-a8     &ndash; Select the cortex-a8 processor.
  cortex-a9     &ndash; Select the cortex-a9 processor.
  cortex-a9-mp  &ndash; Select the cortex-a9-mp processor.
  cortex-m0     &ndash; Select the cortex-m0 processor.
  cortex-m3     &ndash; Select the cortex-m3 processor.
  cortex-m4     &ndash; Select the cortex-m4 processor.
  cortex-r5     &ndash; Select the cortex-r5 processor.
  ep9312        &ndash; Select the ep9312 processor.
  generic       &ndash; Select the generic processor.
  iwmmxt        &ndash; Select the iwmmxt processor.
  krait         &ndash; Select the krait processor.
  mpcore        &ndash; Select the mpcore processor.
  mpcorenovfp   &ndash; Select the mpcorenovfp processor.
  strongarm     &ndash; Select the strongarm processor.
  strongarm110  &ndash; Select the strongarm110 processor.
  strongarm1100 &ndash; Select the strongarm1100 processor.
  strongarm1110 &ndash; Select the strongarm1110 processor.
  swift         &ndash; Select the swift processor.
  xscale        &ndash; Select the xscale processor.
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM Cortex-M0 Overview]]></title>
    <link href="http://sushihangover.github.io/arm-cortex-m0-overview"/>
    <updated>2014-02-17T06:02:25-08:00</updated>
    <id>http://sushihangover.github.io/arm-cortex-m0-overview</id>
    <content type="html"><![CDATA[<p>ARM Cortex-M0 Overview By: Daniel Widyanto September 2010</p>

<p  style=" margin: 12px auto 6px auto; font-family: Helvetica,Arial,Sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 14px; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none; display: block;">   <a title="View ARM Cortex-M0 Overview on Scribd" href="http://www.scribd.com/doc/38226967"  style="text-decoration: underline;" >ARM Cortex-M0 Overview</a></p>


<iframe class="scribd_iframe_embed" src="http://sushihangover.github.io//www.scribd.com/embeds/38226967/content?start_page=1&view_mode=scroll&show_recommendations=true" data-auto-height="false" data-aspect-ratio="undefined" scrolling="no" id="doc_32615" width="100%" height="600" frameborder="0"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bare Metal ARM Terminology]]></title>
    <link href="http://sushihangover.github.io/bare-metal-arm-terminology"/>
    <updated>2014-02-16T21:35:45-08:00</updated>
    <id>http://sushihangover.github.io/bare-metal-arm-terminology</id>
    <content type="html"><![CDATA[<p><a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS</a> : ARM® <strong>C</strong>ortex™ <strong>M</strong>icrocontroller <strong>S</strong>oftware <strong>I</strong>nterface <strong>S</strong>tandard</p>

<p>Thread mode :</p>

<blockquote><p>Used to execute application software. The processor enters Thread mode when it comes out of reset.</p></blockquote>

<p>Privileged or unprivileged software execution :</p>

<blockquote><p>Cortex-M0 do not support different privilege levels. Software execution is always privileged; i.e. Software can access all the features of the processor. Other ARM series do support pri and unpri execution.</p></blockquote>

<p>Handler mode :</p>

<blockquote><p>Used to handle exceptions. The processor returns to Thread mode when it has finished all exception processing</p></blockquote>

<p>SysTick : A 24-bit count-down timer.</p>

<blockquote><p>This timer is the basis for a <em>ticktimer</em> for an embedded Real Time Operating System (RTOS) like FreeRTOS. And, yes, it can be used as a simple counter.</p></blockquote>

<p>System Control Block :</p>

<blockquote><p>Provides system implementation information and system control, including configuration, control,and reporting of system exceptions.</p></blockquote>

<p>NVIC : Nested Vectored Interrupt Controller</p>

<blockquote><p>In the Cortex-M0, Cortex-M0+ and Cortex-M1 processors, the NVIC support up to 32 interrupts (IRQ), a Non-Maskable Interrupt (NMI) and various system exceptions, other M series, like M3/M4, can support up to 240 IRQs.
Tail chaining > If another exception is pending when an ISR exits, the processor does not restore all saved registers from the stack and instead moves on to the next ISR. This reduces the latency when switching from one exception handler to another.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Is Bare Metal ARM]]></title>
    <link href="http://sushihangover.github.io/what-is-bare-metal-arm"/>
    <updated>2014-02-16T08:12:02-08:00</updated>
    <id>http://sushihangover.github.io/what-is-bare-metal-arm</id>
    <content type="html"><![CDATA[<h2>What is Bare Metal ARM Development?</h2>

<blockquote><p>Bare-Metal ARM Development, also called <a href="http://en.wikipedia.org/wiki/Bare_machine">Bare-Machine</a> is the development of &lsquo;embedded&rsquo; applications, that run without an operating system or other supporting programs, maybe a bootloader, on an ARM processor. The application sits on top of the “bare metal”, runs ARM instructions (including THUMB), directly controls the processor (MCU) to manage power consumption, GPIOs, ADC, DAC, etc&hellip;</p></blockquote>
]]></content>
  </entry>
  
</feed>
