<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C# | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2015-06-09T16:04:33-07:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[RobertN]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GtkSharp-Explorer Update for Irony]]></title>
    <link href="http://sushihangover.github.io/gtksharp-explorer-update-for-irony/"/>
    <updated>2014-02-12T08:14:14-08:00</updated>
    <id>http://sushihangover.github.io/gtksharp-explorer-update-for-irony</id>
    <content type="html"><![CDATA[<p><a href="images/Irony-GtkSharp-Explorer-OS-X-ScreenCap.png">{% img left images/Irony-GtkSharp-Explorer-OS-X-ScreenCap.png  360 240 &lsquo;Irony.GtkSharp.Explorer&rsquo; &lsquo;Irony GtkSharp Explorer&rsquo; %}</a> I was working on a <a href="https://irony.codeplex.com">Irony/C#</a> based DSL that I wrote awhile back and noticed that I had some strange NameSpace issues with the GTK UI (exposed only within Xamarin&rsquo;s Stetic Designer, not sure how those naming conflicts were not a compile time error&hellip;).</p>

<p>Updated source for my Gtk# addition to Irony is on GitHub now. <strong>Remember that my additions are on the &ldquo;gtksharp-explorer&rdquo; branch.</strong>
{% codeblock lang:bash %}
git branch &ndash;all
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/gtksharp-explorer
  remotes/origin/master
  remotes/origin/xplat-nunit-fix
git checkout gtksharp-explorer
  Branch gtksharp-explorer set up to track remote branch gtksharp-explorer from origin.
  Switched to a new branch &lsquo;gtksharp-explorer&rsquo;</p>

<p>git branch &ndash;all
* gtksharp-explorer
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/gtksharp-explorer
  remotes/origin/master
  remotes/origin/xplat-nunit-fix<br/>
open Irony_All.MonoDevelop.sln
{% endcodeblock %}</p>

<hr />

<h1>Grammar Explorer based on Gtk#</h1>

<p><em>For cross-platform Irony work in Mono 3.2.X and MonoDevelop/Xamarin 4.1.X/4.2.X</em>
Instructions for building on Mono:</p>

<h2>Via MonoDevelop/Xamarin IDE:</h2>

<ul>
<li>Release or Debug Targets:
      Load and build via the Irony_All.MonoDevelop.sln
Via cmd line:</li>
</ul>


<hr />

<ul>
<li><p>Release:
xbuild /p:Configuration=Release Irony_All.MonoDevelop.sln
mono Irony.GrammarExplorer.GtkSharp/bin/Release/Irony.GrammarExplorer.GtkSharp.exe</p></li>
<li><p>Debug:
xbuild /p:Configuration=Release Irony_All.MonoDevelop.sln
mono Irony.GrammarExplorer.GtkSharp/bin/Debug/Irony.GrammarExplorer.GtkSharp.exe</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OMeta Binary Data Parsing]]></title>
    <link href="http://sushihangover.github.io/ometa-binary-data-parsing/"/>
    <updated>2014-02-10T00:00:00-08:00</updated>
    <id>http://sushihangover.github.io/ometa-binary-data-parsing</id>
    <content type="html"><![CDATA[<p><a href="http://joshondesign.com/">Josh Marinacci </a>has a blog post concerning using OMeta to parse binary data and while there was not a complete cut/paste of all the Javascript code needed to run it in <a href="http://tinlizzie.org/ometa-js">OMeta/JS</a>, I saved his grammar for review as I was working on binary parsing using an OMeta that was using C# as the host language. Recently I give the link of his posting to someone else, but turns out Josh&rsquo;s blog was offline (crashed?).  (Update; Appears his blog is working again, so you can refer to the link below for his original post)</p>

<p>So I dug up what I had and whipped up an OMeta/JS example for a complete working proof of concept and here are the results. I am not a JavaScript kind-of-guy, so be nice regarding the code. ;-)</p>

<p>Note: The W3 spec has 18 chunks that can be defined in PNG files and I added &lsquo;iTXt&rsquo; to Josh&rsquo;s original as the PNG I was using as an example had a large chunk of XML data in it, but a lot of chunks are still missing as this is just a proof of concept and the original binaries that I was parsing were not PNGs, but custom AMF2 byte streams that were getting converted to objects &lsquo;on the 'fly&rsquo; via IlGenerator in C#&hellip;</p>

<p>Original PNG parse concept from Josh is at the following link assuming he gets the blog working: <a href="http://joshondesign.com/2013/03/18/ConciseComputing">http://joshondesign.com/2013/03/18/ConciseComputing</a></p>

<p>And his related email thread on vpri.org : <a href="http://vpri.org/pipermail/ometa/2013-March/000524.html">http://vpri.org/pipermail/ometa/2013-March/000524.html</a></p>

<p>So if you load up OMeta/JS, the complete grammar and Javascript functions needed is shown below. Just open up your JS console before doing a &ldquo;Do It&rdquo; so you can see the chunk information found in the PNG and interact with the final object.</p>

<p>Here is an example console output of parsing a PNG file via this OMeta/JS script:</p>

<pre><code>[Log] loaded
[Log] got 24648 bytes
[Log] i32 : 13 &lt;= [13, 0, 0, 0]
[Log] ChunkType :IHDR : [73, 72, 68, 82]
[Log] i32 : 139 &lt;= [139, 0, 0, 0]
[Log] i32 : 119 &lt;= [119, 0, 0, 0]
[Log] i32 : 25 &lt;= [25, 0, 0, 0]
[Log] ChunkType :tEXt : [116, 69, 88, 116]
[Log] String:SoftwareAdobe ImageReady (...byteArrayOmitted...)
[Log] i32 : 1974 &lt;= [182, 7, 0, 0]
[Log] ChunkType :iTXt : [105, 84, 88, 116]
[Log] String:ML:com.adobe.xmp&lt;?xpacket begin="ï»¿" id="W5M (...only first 50 bytes shown...)
[Log] i32 : 22568 &lt;= [40, 88, 0, 0]
[Log] ChunkType :IDAT : [73, 68, 65, 84]
[Log] i32 : 0 &lt;= [0, 0, 0, 0]
[Log] ChunkType :IEND : [73, 69, 78, 68]
[Log] ["PNG HEADER", Array[5], Array[0]]
</code></pre>

<p>This is a working example of parsing binary data parsing in Ometa/JS.
{% codeblock OMeta/JS PNG Parse lang:js <a href="https://gist.github.com/sushihangover/8919188">https://gist.github.com/sushihangover/8919188</a> %}
ometa BinaryParser &lt;: Parser {
    // Portable Network Graphics (PNG) Specification (Second Edition)
    // <a href="http://www.w3.org/TR/PNG/">http://www.w3.org/TR/PNG/</a>
    // Note: not all chunk are defined, this is just a POC
    //entire PNG stream
    START  = [header:h (chunk+):c number*:n] -> [h,c,n],</p>

<pre><code>//chunk definition
chunk  = int4:len str4:t apply(t,len):d byte4:crc
    -&gt; [#chunk, [#type, t], [#length, len], [#data, d], [#crc, crc]],

//chunk types
IHDR :len  = int4:w int4:h byte:dep byte:type byte:comp byte:filter byte:inter
    -&gt; {type:"IHDR", data:{width:w, height:h, bitdepth:dep, colortype:type, compression:comp, filter:filter, interlace:inter}},
gAMA :len  = int4:g                  -&gt; {type:"gAMA", value:g},
pHYs :len  = int4:x int4:y byte:u    -&gt; {type:"pHYs", x:x, y:y, units:u},
tEXt :len  = repeat('byte',len):d    -&gt; {type:"tEXt", data:toAscii(d)},
iTXt :len  = repeat('byte',len):d    -&gt; {type:"iTXt", data:toShortAscii(d)},
tIME :len  = int2:y byte:mo byte:day byte:hr byte:min byte:sec
    -&gt; {type:"tIME", year:y, month:mo, day:day, hour:hr, minute:min, second:sec},
IDAT :len  = repeat('byte',len):d    -&gt; {type:"IDAT", data:"omitted"},
IEND :len  = repeat('byte',len):d    -&gt; {type:"IEND"},

//useful definitions
byte    = number,
header  = 137 80 78 71 13 10 26 10    -&gt; "PNG HEADER",        //mandatory header
int2    = byte:a byte:b               -&gt; byteArrayToInt16([b,a]),  //2 bytes to a 16bit integer
int4    = byte:a byte:b byte:c byte:d -&gt; byteArrayToInt32([d,c,b,a]), //4 bytes to 32bit integer
str4    = byte:a byte:b byte:c byte:d -&gt; toChunkType([a,b,c,d]),  //4 byte string
byte4   = repeat('byte',4):d -&gt; d,
END
</code></pre>

<p>}
BinaryParser.repeat = function(rule, count) {
  var ret = [];
  for(var i=0; i&lt;count; i++) {
     ret.push(this._apply(rule));
  }
  return ret;
}
toAscii = function(byteArray) {
  var foo = String.fromCharCode.apply(String, byteArray);
  console.log (&ldquo;String:&rdquo; + foo + &ldquo; (&hellip;byteArrayOmitted&hellip;)&rdquo;);
  return foo;
}
toShortAscii = function(byteArray) {
  var embeddedText = String.fromCharCode.apply(String, byteArray);
  // The iTxt chunk can contain a lot of text/xml, so truncate for proof of concept
  console.log (&ldquo;String:&rdquo; + embeddedText.slice(1, 51) + &ldquo; (&hellip;only first 50 bytes shown&hellip;)&rdquo;);
  return embeddedText;
}
toChunkType = function(byteArray) {
  var aChuckType = String.fromCharCode.apply(String, byteArray);
  console.log (&ldquo;ChunkType :&rdquo; + aChuckType + &ldquo; : &rdquo; + byteArray );
  return aChuckType;
}
byteArrayToInt32  = function(localByteArray) {
  var uint8array = new Uint8Array(localByteArray);
  var uint32array = new Uint32Array(
                    uint8array.buffer,
                    uint8array.byteOffset + uint8array.byteLength - 4,
                    1 // 4Bytes long
                  );
  var newInt32 = uint32array[0];
  console.log ( &ldquo;i32 : &rdquo; + newInt32 + &ldquo; &lt;= &rdquo; + localByteArray );
  return newInt32;
}
byteArrayToInt16  = function(byteArray) {
  var ints = [];
  alert(byteArray.length);
  for (var i = 0; i &lt; byteArray.length; i += 2) {
    //ints.push((byteArray[i] &lt;&lt; 8) | (byteArray[i+1]));
  }
  console.log (ints);
  return ints;
}
fetchBinary = function() {
    var req = new XMLHttpRequest();
    req.open(&ldquo;GET&rdquo;,&ldquo;<a href="http://sushihangover.azurewebsites.net/Content/Static/IronyLogoSmall.png">http://sushihangover.azurewebsites.net/Content/Static/IronyLogoSmall.png</a>&rdquo;,true);
    req.responseType = &ldquo;arraybuffer&rdquo;;
    req.onload = function(e) {
        console.log(&ldquo;loaded&rdquo;);
        var buf = req.response;
        if(buf) {
            var byteArray = new Uint8Array(buf);
            console.log(&ldquo;got &rdquo; + byteArray.byteLength + &ldquo; bytes&rdquo;);
            var arr = [];
            for(var i=0; i&lt;byteArray.byteLength; i++) {
                arr.push(byteArray[i]);
            }
            // watch out if you uncomment the next line, it can kill your browser w/ large png files
            // console.log(arr);
            var parserResults = BinaryParser.match(arr, &ldquo;START&rdquo;);
            console.log(parserResults);
        }
    }
    req.send(null);
};
fetchBinary();
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MonoMac: Detect When Mac Sleeps or Wakes]]></title>
    <link href="http://sushihangover.github.io/monomac-detect-when-mac-sleeps-or-wakes/"/>
    <updated>2014-01-12T20:44:00-08:00</updated>
    <id>http://sushihangover.github.io/monomac-detect-when-mac-sleeps-or-wakes</id>
    <content type="html"><![CDATA[<p>Saw a question on the Xwt.Mac group concerning getting Sleep and Wake events from MonoMac/C# on OS-X. Normally I would look for those event on the NSApplication default notification center, but a quick look at the Apple developer site quickly directed me to the those events being on the NSWorkspace&rsquo;s notification center, so another quick look in MonoMac and lucky those are already exposed so you do not have to do the AddObserver work yourself, but finding them in the &lsquo;online MonoMac API&rsquo; did not return any direct results(?)&hellip; So here is my answer from that group in case anyone else google/bing this in the future:</p>

<p>Sleep and Wake are available on the NSWorkspace&rsquo;s notification center and MonoMac exposes those so so you do not have to write the AddObserver code yourself:</p>

<p>Apple Dev info on <a href="https://developer.apple.com/library/mac/qa/qa1340/_index.html">NSWorkspaceWillSleepNotification &amp;NSWorkspaceDidWakeNotification</a></p>

<p>{% codeblock C# &ldquo;Wake and Sleep Events&rdquo; %}
Console.WriteLine (&ldquo;Add the sleep/wake observers&rdquo;);
NSWorkspace.Notifications.ObserveWillSleep ((object sender, NSNotificationEventArgs e) => {
    Console.Write (&ldquo;Your Mac is getting sleepy\n&rdquo;);
);
NSWorkspace.Notifications.ObserveDidWake ((object sender, NSNotificationEventArgs e) => {
    Console.Write (&ldquo;Time to go to work again\n&rdquo;);
};
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PlayScript :What Happened to the Open Source Version on GitHub]]></title>
    <link href="http://sushihangover.github.io/playscript-what-happened-to-the-open-source-version-on-github/"/>
    <updated>2013-12-27T19:04:55-08:00</updated>
    <id>http://sushihangover.github.io/playscript-what-happened-to-the-open-source-version-on-github</id>
    <content type="html"><![CDATA[<p>Poof: An open source project disappears: <a href="https://github.com/playscript/playscript-mono.git">https://github.com/playscript/playscript-mono.git</a></p>

<p>{% img left /images/Playscript404.gif 360 240 &lsquo;PlayScript, Going, going, gone&rsquo; %}
I am assuming with removal of PlayScript&rsquo;s public repo on GitHub that the project is either becoming a commercial offering from Xamarin (or Zynga) and future releases will have a license change?</p>

<p>I am assuming there will be some big reveal in the future when Xamarin (and Zynga?) announces Playscript is in Beta for licensed users of Studio, Xamarin.iOS and Xamarin.Andriod, &hellip;. Or Not&hellip;..</p>

<blockquote><p>The really important note here is if someone pulls a GitHub repo, you will <strong>LOSE</strong> your GitHub forks! Gone, Poof, No <em>Mas</em>, No warning, No chance to make a backup&hellip; I sure hope you had a complete local backup of your work cause it is now gone from GitHub</p></blockquote>
]]></content>
  </entry>
  
</feed>
