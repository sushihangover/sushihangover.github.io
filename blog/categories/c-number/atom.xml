<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2015-11-08T10:10:03-08:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[RobertN]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PlayScript | Optimizing psc/mcs]]></title>
    <link href="http://sushihangover.github.io/playscript-compiler-optim/"/>
    <updated>2015-10-27T22:20:18-07:00</updated>
    <id>http://sushihangover.github.io/playscript-compiler-optim</id>
    <content type="html"><![CDATA[<p>{% img left <a href="http://sushihangover.github.io/images/PlayscriptLogo_small.png">http://sushihangover.github.io/images/PlayscriptLogo_small.png</a> %}</p>

<p><a href="http://ericlippert.com">Eric Lippert</a> has a couple of recent posts that I have been reviewing in conjuction with the PlayScript version of Mono&rsquo;s mcs (psc) as some of the things devs do in ActionScript 3.0 are targeted to making Flash&rsquo;s AVM run efficiently does not always make the cut for a C#/CLR oriented compiler. Many of these items revolve around arrays and vector and misuse of the generic (dynamic) Object types, but strings, associative operations, and nulls need some love also and his posts are very insightful as how C# is optimized in certain areas.</p>

<p>{% pullquote %}
<strong>Great</strong> reading for any C#/CLR devs, {&ldquo; including PowerShell DevOps &rdquo;} that are bundling their custom C# written assemblies to speed up their PS modules.
{% endpullquote %}</p>

<p><a href="http://ericlippert.com/2015/10/27/optimizing-associative-operations/">Optimizing associative operations</a></p>

<p><a href="http://ericlippert.com/2013/06/17/string-concatenation-behind-the-scenes-part-one/">String concatenation behind the scenes, part one</a></p>

<p><a href="http://ericlippert.com/2013/06/24/string-concatenation-behind-the-scenes-part-two/">String concatenation behind the scenes, part two</a></p>

<p>He also has a great series on Nullable micro-optimizations that start here:</p>

<p><a href="http://ericlippert.com/2012/12/20/nullable-micro-optimizations-part-one/">Nullable micro-optimizations, part one</a></p>

<p>PlayScript Github repo is <a href="https://github.com/PlayScriptRedux/playscript">here</a> check it out now!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PlayScript | Exception Filters]]></title>
    <link href="http://sushihangover.github.io/playscript-exception-filters/"/>
    <updated>2015-08-17T18:34:18-07:00</updated>
    <id>http://sushihangover.github.io/playscript-exception-filters</id>
    <content type="html"><![CDATA[<p>{% img left <a href="http://sushihangover.github.io/images/PlayscriptLogo_small.png">http://sushihangover.github.io/images/PlayscriptLogo_small.png</a> %} <a href="https://github.com/PlayScriptRedux/playscript">PlayScript</a> (.play) now has Exception Filters like C# 6.0.</p>

<p>These are actually really cool and nice addition to ActionScript.</p>

<p>From the <a href="http://blogs.msdn.com/b/csharpfaq">C# Frequently Asked Questions</a> blog:</p>

<blockquote><p>Exception filters are a CLR capability that is exposed in Visual Basic and F#, but hasn’t been in C# – until now. This is what they look like in C#:</p></blockquote>

<pre><code>try { … } 
catch (MyException e) if (myfilter(e)) 
{ 
     … 
}
</code></pre>

<p><a href="http://blogs.msdn.com/b/csharpfaq/archive/2014/11/20/new-features-in-c-6.aspx">New Features in C# 6</a></p>

<p>And here is what they look like in PlayScript:</p>

<h3>play/test-ps-ex-filter-01.play</h3>

<pre><code>package {
    public class Foo {
        public static function Main():int {
        var x:int = 4;
        try {
            throw new Error("Throw");
        } catch (e:Error) if (x &gt; 0) {
            trace("Catch");
            return 0;
        }
        return 1;
        }
    }
}
</code></pre>

<h3>play/test-ps-ex-filter-02.play</h3>

<pre><code>package {
    public class Foo {
        public static function Main():int {
        var x:int = 4;
        try {
            x = 5;
            throw new Error("Throw");
        } catch (e:Error) if (x &lt; 5) {
            trace("No Catch Please");
            return 0;
        } catch (myError:Error) {
            trace("Catch Here");
            return 0;
        }
        return 1;
        }
    }
}
</code></pre>

<p>If you have any problems with them, post an <a href="https://github.com/PlayScriptRedux/playscript/issues">issue</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C# - Native Interop Helloworld]]></title>
    <link href="http://sushihangover.github.io/c-number-native-interop-helloworld/"/>
    <updated>2015-06-23T18:40:28-07:00</updated>
    <id>http://sushihangover.github.io/c-number-native-interop-helloworld</id>
    <content type="html"><![CDATA[<h4>The simplest Interop case HelloWorld I can create, give it a try and see what happens:</h4>

<p><code>&gt;cat countbyone.cpp</code></p>

<pre><code>extern "C" int SomeMethod(int num) {
  return num++;
}
</code></pre>

<p><strong>Compile your shared library:</strong></p>

<ul>
<li>Linux:
<code>gcc -g -shared -fPIC countbyone.cpp -o libcountbyone.so</code></li>
<li>OS-X:
<code>clang -dynamiclib countbyone.cpp -o libcoutbyone.dylib</code></li>
</ul>


<p><code>&gt;cat interop.cs</code></p>

<pre><code>using System;
using System.Runtime.InteropServices;
namespace InteropDemo
{
    class MainClass
    {
        [DllImport("countbyone")]
        private static extern int SomeMethod(int num);

        public static void Main (string[] args)
        {
            var x = SomeMethod(0);
            Console.WriteLine(x);
        }
    }
}
</code></pre>

<p><strong>Compile your .Net/Mono app:</strong></p>

<p><code>&gt;mcs interop.cs</code></p>

<p><strong>Run it:</strong></p>

<pre><code>&gt;mono interop.exe
1
</code></pre>

<p><strong>Output should be 1 and no errors&hellip;</strong></p>

<h4>If the shared (native) library is not found, you receive:</h4>

<p><code>XXXXX failed to initialize, the exception is: System.DllNotFoundException
</code></p>

<h4>If you have a entry point mismatch you would receive a:</h4>

<p><code>XXXXX failed to initialize, the exception is: System.EntryPointNotFoundException
</code></p>

<p>From my answer on <a href="http://stackoverflow.com/questions/31013147/check-if-p-invoke-was-successful/31015964#31015964">Stackoverflow</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GtkSharp-Explorer update for Irony]]></title>
    <link href="http://sushihangover.github.io/gtksharp-explorer-update-for-irony/"/>
    <updated>2014-02-12T08:14:14-08:00</updated>
    <id>http://sushihangover.github.io/gtksharp-explorer-update-for-irony</id>
    <content type="html"><![CDATA[<p><a href="images/Irony-GtkSharp-Explorer-OS-X-ScreenCap.png">{% img left images/Irony-GtkSharp-Explorer-OS-X-ScreenCap.png  360 240 &lsquo;Irony.GtkSharp.Explorer&rsquo; &lsquo;Irony GtkSharp Explorer&rsquo; %}</a> I was working on a <a href="https://irony.codeplex.com">Irony/C#</a> based DSL that I wrote awhile back and noticed that I had some strange NameSpace issues with the GTK UI (exposed only within Xamarin&rsquo;s Stetic Designer, not sure how those naming conflicts were not a compile time error&hellip;).</p>

<p>Updated source for my Gtk# addition to Irony is on GitHub now. <strong>Remember that my additions are on the &ldquo;gtksharp-explorer&rdquo; branch.</strong>
{% codeblock lang:bash %}
git branch &ndash;all
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/gtksharp-explorer
  remotes/origin/master
  remotes/origin/xplat-nunit-fix
git checkout gtksharp-explorer
  Branch gtksharp-explorer set up to track remote branch gtksharp-explorer from origin.
  Switched to a new branch &lsquo;gtksharp-explorer&rsquo;</p>

<p>git branch &ndash;all
* gtksharp-explorer
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/gtksharp-explorer
  remotes/origin/master
  remotes/origin/xplat-nunit-fix<br/>
open Irony_All.MonoDevelop.sln
{% endcodeblock %}</p>

<hr />

<h1>Grammar Explorer based on Gtk#</h1>

<p><em>For cross-platform Irony work in Mono 3.2.X and MonoDevelop/Xamarin 4.1.X/4.2.X</em>
Instructions for building on Mono:</p>

<h2>Via MonoDevelop/Xamarin IDE:</h2>

<ul>
<li>Release or Debug Targets:
      Load and build via the Irony_All.MonoDevelop.sln
Via cmd line:</li>
</ul>


<hr />

<ul>
<li><p>Release:
xbuild /p:Configuration=Release Irony_All.MonoDevelop.sln
mono Irony.GrammarExplorer.GtkSharp/bin/Release/Irony.GrammarExplorer.GtkSharp.exe</p></li>
<li><p>Debug:
xbuild /p:Configuration=Release Irony_All.MonoDevelop.sln
mono Irony.GrammarExplorer.GtkSharp/bin/Debug/Irony.GrammarExplorer.GtkSharp.exe</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OMeta Binary data parsing]]></title>
    <link href="http://sushihangover.github.io/ometa-binary-data-parsing/"/>
    <updated>2014-02-10T00:00:00-08:00</updated>
    <id>http://sushihangover.github.io/ometa-binary-data-parsing</id>
    <content type="html"><![CDATA[<p><a href="http://joshondesign.com/">Josh Marinacci </a>has a blog post concerning using OMeta to parse binary data and while there was not a complete cut/paste of all the Javascript code needed to run it in <a href="http://tinlizzie.org/ometa-js">OMeta/JS</a>, I saved his grammar for review as I was working on binary parsing using an OMeta that was using C# as the host language. Recently I give the link of his posting to someone else, but turns out Josh&rsquo;s blog was offline (crashed?).  (Update; Appears his blog is working again, so you can refer to the link below for his original post)</p>

<p>So I dug up what I had and whipped up an OMeta/JS example for a complete working proof of concept and here are the results. I am not a JavaScript kind-of-guy, so be nice regarding the code. ;-)</p>

<p>Note: The W3 spec has 18 chunks that can be defined in PNG files and I added &lsquo;iTXt&rsquo; to Josh&rsquo;s original as the PNG I was using as an example had a large chunk of XML data in it, but a lot of chunks are still missing as this is just a proof of concept and the original binaries that I was parsing were not PNGs, but custom AMF2 byte streams that were getting converted to objects &lsquo;on the 'fly&rsquo; via IlGenerator in C#&hellip;</p>

<p>Original PNG parse concept from Josh is at the following link assuming he gets the blog working: <a href="http://joshondesign.com/2013/03/18/ConciseComputing">http://joshondesign.com/2013/03/18/ConciseComputing</a></p>

<p>And his related email thread on vpri.org : <a href="http://vpri.org/pipermail/ometa/2013-March/000524.html">http://vpri.org/pipermail/ometa/2013-March/000524.html</a></p>

<p>So if you load up OMeta/JS, the complete grammar and Javascript functions needed is shown below. Just open up your JS console before doing a &ldquo;Do It&rdquo; so you can see the chunk information found in the PNG and interact with the final object.</p>

<p>Here is an example console output of parsing a PNG file via this OMeta/JS script:</p>

<pre><code>[Log] loaded
[Log] got 24648 bytes
[Log] i32 : 13 &lt;= [13, 0, 0, 0]
[Log] ChunkType :IHDR : [73, 72, 68, 82]
[Log] i32 : 139 &lt;= [139, 0, 0, 0]
[Log] i32 : 119 &lt;= [119, 0, 0, 0]
[Log] i32 : 25 &lt;= [25, 0, 0, 0]
[Log] ChunkType :tEXt : [116, 69, 88, 116]
[Log] String:SoftwareAdobe ImageReady (...byteArrayOmitted...)
[Log] i32 : 1974 &lt;= [182, 7, 0, 0]
[Log] ChunkType :iTXt : [105, 84, 88, 116]
[Log] String:ML:com.adobe.xmp&lt;?xpacket begin="ï»¿" id="W5M (...only first 50 bytes shown...)
[Log] i32 : 22568 &lt;= [40, 88, 0, 0]
[Log] ChunkType :IDAT : [73, 68, 65, 84]
[Log] i32 : 0 &lt;= [0, 0, 0, 0]
[Log] ChunkType :IEND : [73, 69, 78, 68]
[Log] ["PNG HEADER", Array[5], Array[0]]
</code></pre>

<p>This is a working example of parsing binary data parsing in Ometa/JS.
{% codeblock OMeta/JS PNG Parse lang:js <a href="https://gist.github.com/sushihangover/8919188">https://gist.github.com/sushihangover/8919188</a> %}
ometa BinaryParser &lt;: Parser {
    // Portable Network Graphics (PNG) Specification (Second Edition)
    // <a href="http://www.w3.org/TR/PNG/">http://www.w3.org/TR/PNG/</a>
    // Note: not all chunk are defined, this is just a POC
    //entire PNG stream
    START  = [header:h (chunk+):c number*:n] -> [h,c,n],</p>

<pre><code>//chunk definition
chunk  = int4:len str4:t apply(t,len):d byte4:crc
    -&gt; [#chunk, [#type, t], [#length, len], [#data, d], [#crc, crc]],

//chunk types
IHDR :len  = int4:w int4:h byte:dep byte:type byte:comp byte:filter byte:inter
    -&gt; {type:"IHDR", data:{width:w, height:h, bitdepth:dep, colortype:type, compression:comp, filter:filter, interlace:inter}},
gAMA :len  = int4:g                  -&gt; {type:"gAMA", value:g},
pHYs :len  = int4:x int4:y byte:u    -&gt; {type:"pHYs", x:x, y:y, units:u},
tEXt :len  = repeat('byte',len):d    -&gt; {type:"tEXt", data:toAscii(d)},
iTXt :len  = repeat('byte',len):d    -&gt; {type:"iTXt", data:toShortAscii(d)},
tIME :len  = int2:y byte:mo byte:day byte:hr byte:min byte:sec
    -&gt; {type:"tIME", year:y, month:mo, day:day, hour:hr, minute:min, second:sec},
IDAT :len  = repeat('byte',len):d    -&gt; {type:"IDAT", data:"omitted"},
IEND :len  = repeat('byte',len):d    -&gt; {type:"IEND"},

//useful definitions
byte    = number,
header  = 137 80 78 71 13 10 26 10    -&gt; "PNG HEADER",        //mandatory header
int2    = byte:a byte:b               -&gt; byteArrayToInt16([b,a]),  //2 bytes to a 16bit integer
int4    = byte:a byte:b byte:c byte:d -&gt; byteArrayToInt32([d,c,b,a]), //4 bytes to 32bit integer
str4    = byte:a byte:b byte:c byte:d -&gt; toChunkType([a,b,c,d]),  //4 byte string
byte4   = repeat('byte',4):d -&gt; d,
END
</code></pre>

<p>}
BinaryParser.repeat = function(rule, count) {
  var ret = [];
  for(var i=0; i&lt;count; i++) {
     ret.push(this._apply(rule));
  }
  return ret;
}
toAscii = function(byteArray) {
  var foo = String.fromCharCode.apply(String, byteArray);
  console.log (&ldquo;String:&rdquo; + foo + &ldquo; (&hellip;byteArrayOmitted&hellip;)&rdquo;);
  return foo;
}
toShortAscii = function(byteArray) {
  var embeddedText = String.fromCharCode.apply(String, byteArray);
  // The iTxt chunk can contain a lot of text/xml, so truncate for proof of concept
  console.log (&ldquo;String:&rdquo; + embeddedText.slice(1, 51) + &ldquo; (&hellip;only first 50 bytes shown&hellip;)&rdquo;);
  return embeddedText;
}
toChunkType = function(byteArray) {
  var aChuckType = String.fromCharCode.apply(String, byteArray);
  console.log (&ldquo;ChunkType :&rdquo; + aChuckType + &ldquo; : &rdquo; + byteArray );
  return aChuckType;
}
byteArrayToInt32  = function(localByteArray) {
  var uint8array = new Uint8Array(localByteArray);
  var uint32array = new Uint32Array(
                    uint8array.buffer,
                    uint8array.byteOffset + uint8array.byteLength - 4,
                    1 // 4Bytes long
                  );
  var newInt32 = uint32array[0];
  console.log ( &ldquo;i32 : &rdquo; + newInt32 + &ldquo; &lt;= &rdquo; + localByteArray );
  return newInt32;
}
byteArrayToInt16  = function(byteArray) {
  var ints = [];
  alert(byteArray.length);
  for (var i = 0; i &lt; byteArray.length; i += 2) {
    //ints.push((byteArray[i] &lt;&lt; 8) | (byteArray[i+1]));
  }
  console.log (ints);
  return ints;
}
fetchBinary = function() {
    var req = new XMLHttpRequest();
    req.open(&ldquo;GET&rdquo;,&ldquo;<a href="http://sushihangover.azurewebsites.net/Content/Static/IronyLogoSmall.png">http://sushihangover.azurewebsites.net/Content/Static/IronyLogoSmall.png</a>&rdquo;,true);
    req.responseType = &ldquo;arraybuffer&rdquo;;
    req.onload = function(e) {
        console.log(&ldquo;loaded&rdquo;);
        var buf = req.response;
        if(buf) {
            var byteArray = new Uint8Array(buf);
            console.log(&ldquo;got &rdquo; + byteArray.byteLength + &ldquo; bytes&rdquo;);
            var arr = [];
            for(var i=0; i&lt;byteArray.byteLength; i++) {
                arr.push(byteArray[i]);
            }
            // watch out if you uncomment the next line, it can kill your browser w/ large png files
            // console.log(arr);
            var parserResults = BinaryParser.match(arr, &ldquo;START&rdquo;);
            console.log(parserResults);
        }
    }
    req.send(null);
};
fetchBinary();
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
