<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Arm-none-eabi | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/arm-none-eabi/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2014-04-22T16:01:21-07:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[Robert N.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[New ARM 'Machines' in QEMU 2.0]]></title>
    <link href="http://sushihangover.github.io/new-arm-features-in-qemu-2-dot-0"/>
    <updated>2014-03-14T23:32:19-07:00</updated>
    <id>http://sushihangover.github.io/new-arm-features-in-qemu-2-dot-0</id>
    <content type="html"><![CDATA[<p><a href="/images/QEMU_new_machine_large.png">{% img left /images/QEMU_new_machine_small.png &ldquo;QEMU 2.0 New ARM Machines&rdquo; %}</a>I been using QEMU a lot recently to model some Cortex-M0+ software that I am working on.</p>

<p>While technically speaking QEMU does not have a &ldquo;Cortex-M0(+)&rdquo; cpu in its feature set, it does have a M3 core and I have used it to create some Cortex-M0+ cpus that model some cores from a couple of ARM vendors, and then added some supporting dev boards (&lsquo;machines&rsquo; per QEMU nomenclature). I&rsquo;ve been waiting till the QEMU 2.0 release to get my new ARM coding sorted out as major versions usually cause large changes in APIs, C headers, usage patterns, etc&hellip; and well, QEMU is tough enough to work through and I did not plan on doing it twice&hellip;</p>

<p>Well, we are getting close, <a href="http://wiki.qemu.org/ChangeLog/2.0">QEMU 2.0 RC0</a> just released as a tar ball (not in the git repo?), so I did the download, configured and built on OS-X for &ldquo;arm-softmmu&rdquo;. Everything is great so far, ran some of my work through it and have not found anything amiss. Interesting that the version that shows up as <strong>QEMU emulator version 1.7.90</strong> (BTW: the version on the git master branch is 1.7.5?)</p>

<p>{% codeblock %}
qemu-system-arm -version
QEMU emulator version 1.7.90, Copyright &copy; 2003-2008 Fabrice Bellard
{% endcodeblock %}</p>

<p>There are a few new machines available:</p>

<pre><code>* canon-a1100          Canon PowerShot A1100 IS
* cubieboard           cubietech cubieboard
* virt                 ARM Virtual Machine
</code></pre>

<p>The <a href="http://cubieboard.org">cubie</a> board makes sense as you can  use it to test Linux image builds and what-not. I am not sure of the usage pattern for the &ldquo;Canon PowerShot A1100 DIGIC&rdquo;, is the <a href="http://en.wikipedia.org/wiki/DIGIC">DIGIC</a> 4 Image Processor available for purchuse? I&rsquo;ll have to look into this one as it leaves me confused.</p>

<p>The interesting one is the fact that there is now a &lsquo;virt&rsquo; machine for ARM. I&rsquo;m not sure that I will personally have a use for using <a href="http://wiki.libvirt.org/page/Virtio">virtio</a> devices in any embedded ARM dev work, but you never know.</p>

<p>Nothing new in the ARM cpu listing, so I guess I will continue with my ARM core and machine work&hellip;</p>

<p>The change log for ARM shows the following:</p>

<pre><code>* Support for "-M virt", a board type that only uses virtio devices
* Support for "-cpu host" when running under KVM
* Support for new 32-bit mode ARMv8 instructions in TCG
* Support for AArch64 disassembling (requires a C++ compiler to be installed on the host)
* Support for AArch64 user-mode emulation
* Initial support for KVM on AArch64 systems (some features such as migration are not yet implemented)
* Support for the Canon PowerShot A1100 DIGIC board using "-M canon-a1100"
* Support for the allwinner-a10-based board "-M cubieboard"
* Support for flow control in the Cadence UART
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cortex-M0 & M3 SysTick: Polling vs. Interrupt Driven]]></title>
    <link href="http://sushihangover.github.io/cortex-m-systick-polling-vs-interrupts"/>
    <updated>2014-03-09T19:24:34-07:00</updated>
    <id>http://sushihangover.github.io/cortex-m-systick-polling-vs-interrupts</id>
    <content type="html"><![CDATA[<p><a href="/images/ARM_CortexM_CMSIS_large.png">{% img left /images/ARM_CortexM_CMSIS_small.png &ldquo;CMSIS Version 3 Block Diagram (Source: Arm.com)&rdquo; %}</a>
This time around, lets use the CMSIS abstraction layer to access the SysTick core peripheral.</p>

<p>This peripheral can be used to provide the core timer to an embedded RTOS kernel, such as FreeRTOS, or to provide application timing events to know when to read some attached sensors or such. In the most basic form, it provides a pollable countdown value. This value is decreased from a user settable value (<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0179b/ar01s02s08.html">Reload Value</a>) on every clock tick. If it configured as an interrupt, the function assigned activates every n+1 clock ticks.</p>

<p>I used Clang/LLVM to compile a simple app that shows you how to set the reload value, read (poll) the internal SysTick value or enable it as an interrupt.</p>

<p>The semihosting output of this app (via QEMU):
{% codeblock lang:bash %}
qemu-system-arm -M lm3s811evb -cpu cortex-m3 -semihosting -kernel  bin/main.axf
SysTick should not be active yet&hellip;
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
Enable SysTick and lets poll it&hellip;
&hellip;Current value: 6913
&hellip;Current value: 2825
&hellip;Current value: 2450
&hellip;Current value: 2138
&hellip;Current value: 1825
&hellip;Current value: 1525
&hellip;Current value: 1225
&hellip;Current value: 913
&hellip;Current value: 613
&hellip;Current value: 313
Enable SysTick Interrupts and watch local var get incremented&hellip;
&hellip;myTicks = 1; SysTick->VAL = 0
&hellip;myTicks = 2; SysTick->VAL = 3425
&hellip;myTicks = 3; SysTick->VAL = 8725
&hellip;myTicks = 4; SysTick->VAL = 2938
&hellip;myTicks = 5; SysTick->VAL = 8113
&hellip;myTicks = 6; SysTick->VAL = 2550
&hellip;myTicks = 7; SysTick->VAL = 7725
&hellip;myTicks = 8; SysTick->VAL = 2938
&hellip;myTicks = 9; SysTick->VAL = 8125
&hellip;myTicks = 10; SysTick->VAL = 2563
&hellip;myTicks = 11; SysTick->VAL = 8100
&hellip;myTicks = 12; SysTick->VAL = 3038
{% endcodeblock %}</p>

<p>{% codeblock lang:c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &ldquo;CortexM3_xx.h&rdquo;</h1>

<h1>include &lt;core_cm3.h></h1>

<h1>include &lt;stdint.h></h1>

<h1>include &ldquo;svc.h&rdquo;</h1>

<p>volatile uint32_t myTicks;</p>

<p>void SysTick_Handler(void) {
  myTicks++;
  printf(&ldquo;&hellip;myTicks = %lu; SysTick->VAL = %lu\n&rdquo;, myTicks, SysTick->VAL);
}</p>

<p>int main(void) {</p>

<pre><code>printf("SysTick should not be active yet...\n");
for (int x=0; x&lt;10; x++) {
    printf("...Current value: %lu\n", SysTick-&gt;VAL);
}
printf("Enable SysTick and lets poll it...\n");

volatile uint32_t clock = 10000;
SysTick-&gt;LOAD = clock - 1;
/*
    * SysTick_CTRL_CLKSOURCE_Msk : Use core's clock
    * SysTick_CTRL_ENABLE_Msk    : Enable SysTick
    * SysTick_CTRL_TICKINT_Msk   : Active the SysTick interrupt on the NVIC
*/ 
SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
for (int x=0; x&lt;10; x++) {
    printf("...Current value: %lu\n", SysTick-&gt;VAL);
}

printf("Enable SysTick Interrupts and watch local var get incremented...\n");
myTicks = 0;
SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk |  SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk;

while(myTicks &lt;= 10) {
    asm("nop"); // Do nothing till SysTick_Handler been been called at least 10 times
}
exit(0);
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LLVM, CMSIS DSP and Cortex-M3 &amp; M0]]></title>
    <link href="http://sushihangover.github.io/llvm-cmsis-dsp-and-cortex-m3-and-m0"/>
    <updated>2014-03-05T22:34:20-08:00</updated>
    <id>http://sushihangover.github.io/llvm-cmsis-dsp-and-cortex-m3-and-m0</id>
    <content type="html"><![CDATA[<p><a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">{% img left /images/cmsis-version-3-block-diagram.png  &ldquo;CMSIS Version 3 Block Diagram (Source: Arm.com)&rdquo; %}</a> I added ARM&rsquo;s CMSIS 3.01 to my LLVM project and wanted to test out the pre-compiled DSP libraries that are supplied.</p>

<p>I borrowed one of the cos/sin examples and added some semihosting <em>printf</em>s using NEWLIB and cleaned up the code a bit.</p>

<blockquote><p><a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php?tab=Download+CMSIS">CMSIS-DSP</a>: DSP Library Collection with over 60 Functions for various data types: fix-point (fractional q7, q15, q31) and single precision floating-point (32-bit). The library is available for Cortex-M0, Cortex-M3, and Cortex-M4. The Cortex-M4 implementation is optimized for the SIMD instruction set.</p></blockquote>

<p>Updating my Makefile to include the correct CMSIS libraries (<em>arm_cortexM3l_math</em>) for the ld and the currect headers for Clang/LLVM and the result <em>works great</em> for Cortex-M3. I copied the project over and mod&rsquo;d the Makefile so it picks up the correct Cortex-M0 lib (<em>arm_cortexM0l_math</em>) and everything looks on this core also.</p>

<p>Clang/LLVM compile and link:
{% codeblock lang:bash %}
clang -Os  -nostdlib -ffreestanding   -target arm-none-eabi  -mcpu=cortex-m0   -mfloat-abi=soft  -mthumb  -DARM_MATH_CM3 -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/CMSIS/Include   -o obj/arm_sin_cos_example_f32.o -c src/arm_sin_cos_example_f32.c
clang -Os  -nostdlib -ffreestanding   -target arm-none-eabi  -mcpu=cortex-m0   -mfloat-abi=soft  -mthumb  -DARM_MATH_CM3 -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/CMSIS/Include   -o obj/startup.o -c src/startup.c
arm-none-eabi-ld -nostartfiles   -nostdlib -nostartupfiles  &mdash;gc-sections  &mdash;print-gc-sections  -Map bin/main.axf.map  -T src/cortex_M0.ld  &mdash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib/thumb/thumb2 &mdash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/lib/gcc/arm-none-eabi/4.8.3/armv7-m &mdash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/CMSIS/LIB/GCC    obj/arm_sin_cos_example_f32.o obj/startup.o &mdash;start-group &mdash;library=gcc &mdash;library=c &mdash;library=m &mdash;library=arm_cortexM0l_math &mdash;end-group -o bin/main.axf
{% endcodeblock %}</p>

<p>Sample semihousting output from a Cortex-M3:
{% codeblock lang:bash %}
qemu-system-arm -cpu cortex-m3  -semihosting -nographic -kernel  bin/main.axf
Starting Test&hellip;
Cos -1.244917 = 0.320142
Sin -1.244917 = -0.947370
Cos squared 0.320142 = 0.102491
Sin squared -0.947370 = 0.897509
Add 0.102491 and 0.897509 = 1.000000
Cos -4.793534 = 0.081056
Sin -4.793534 = 0.996710
Cos squared 0.081056 = 0.006570
Sin squared 0.996710 = 0.993430
Add 0.006570 and 0.993430 = 1.000000
&hellip;
&hellip;
Cos 1.985805 = -0.403198
Sin 1.985805 = 0.915113
Cos squared -0.403198 = 0.162568
Sin squared 0.915113 = 0.837431
Add 0.162568 and 0.837431 = 1.000000
Ending Test&hellip;
{% endcodeblock %}</p>

<p>{% codeblock lang:c <a href="https://github.com/sushihangover/llvm_baremetal">https://github.com/sushihangover/llvm_baremetal</a> %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;math.h></h1>

<h1>include &ldquo;arm_math.h&rdquo;</h1>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
* Defines each of the tests performed
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; </em>/</p>

<h1>define MAX_BLOCKSIZE   32</h1>

<h1>define DELTA           (0.000001f)</h1>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
* Test input data for Floating point sin_cos example for 32-blockSize
* Generated by the MATLAB randn() function
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; </em>/</p>

<p>const float32_t testInput_f32[MAX_BLOCKSIZE] =<br/>
{  <br/>
 -1.244916875853235400, -4.793533929171324800,  0.360705030233248850,
  0.827929644170887320, -3.299532218312426900,  3.427441903227623800, <br/>
  3.422401784294607700, -0.108308165334010680,  0.941943896490312180,
  0.502609575000365850, -0.537345278736373500,  2.088817392965764500,
 -1.693168684143455700,  6.283185307179590700, -0.392545884746175080,
  0.327893095115825040,  3.070147440456292300,  0.170611405884662230,
 -0.275275082396073010, -2.395492805446796300,  0.847311163536506600,
 -3.845517018083148800,  2.055818378415868300,  4.672594161978930800,
 -1.990923030266425800,  2.469305197656249500,  3.609002606064021000,
 -4.586736582331667500, -4.147080139136136300,  1.643756718868359500,
 -1.150866392366494800,  1.985805026477433800
};</p>

<p>const float32_t testRefOutput_f32 = 1.000000000;</p>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
* Declare Global variables<br/>
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; </em>/
uint32_t blockSize = 32;
float32_t  testOutput;<br/>
float32_t  cosOutput;<br/>
float32_t  sinOutput;<br/>
float32_t  cosSquareOutput;<br/>
float32_t  sinSquareOutput;</p>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
* Max magnitude FFT Bin test
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; </em>/</p>

<p>arm_status status;</p>

<p>int32_t main(void)
{
   float32_t diff;
   uint32_t i;</p>

<p>   printf(&ldquo;Starting Test&hellip;\n&rdquo;);
   for (i=0; i &lt; blockSize; i++)
   {</p>

<pre><code>  cosOutput = arm_cos_f32(testInput_f32[i]); 
  printf("Cos %f = %f\n", testInput_f32[i], cosOutput);

  sinOutput = arm_sin_f32(testInput_f32[i]); 
  printf("Sin %f = %f\n", testInput_f32[i], sinOutput);

  arm_mult_f32(&amp;cosOutput, &amp;cosOutput, &amp;cosSquareOutput, 1); 
  printf("Cos squared %f = %f\n", cosOutput, cosSquareOutput);

  arm_mult_f32(&amp;sinOutput, &amp;sinOutput, &amp;sinSquareOutput, 1); 
  printf("Sin squared %f = %f\n", sinOutput, sinSquareOutput);

  arm_add_f32(&amp;cosSquareOutput, &amp;sinSquareOutput, &amp;testOutput, 1);
  printf("Add %f and %f = %f\n", cosSquareOutput, sinSquareOutput, testOutput);

  /* absolute value of difference between ref and test */ 
  diff = fabsf(testRefOutput_f32 - testOutput); 
  /* Comparison of sin_cos value with reference */ 
  if (diff &gt; DELTA) 
  { 
     printf("Diff failure %f\n", diff);
     exit(EXIT_FAILURE); /* just for QEMU testing */
     while(1); 
  } 
</code></pre>

<p>   }
   printf(&ldquo;Ending Test&hellip;\n&rdquo;);
   exit(EXIT_SUCCESS); /<em> just for QEMU testing </em>/
   while(1); /<em> main function does not return </em>/
}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cortex-M0 vs. M3 : LLVM and LD]]></title>
    <link href="http://sushihangover.github.io/cortex-m0-vs-m3-llvm-and-ld"/>
    <updated>2014-03-05T06:30:13-08:00</updated>
    <id>http://sushihangover.github.io/cortex-m0-vs-m3-llvm-and-ld</id>
    <content type="html"><![CDATA[<p><a href="/images/ARM_Cortex-M_instruction_set_large.png">{% img left /images/ARM_Cortex-M_instruction_set_small.png  &ldquo;ARM Cortex-M instruction set&rdquo; %}</a> One of the issues that you run into using Clang/LLVM as your compiler for bare-metal ARM Cortex cores is you have to directly use arm-none-eabi-ld to do your linking.</p>

<p>Directly using <strong>ld</strong> can be a bit nerve wrecking at times to get the options correct (and the <strong>order</strong> of options does matter) as normally you are just let gcc use collect2 and have it internally execute ld to perform your linking.</p>

<p>One of the areas using it directly that can bite you is not linking to the proper libgcc.a for the Cortex-M that you are targeting. Looking into your <em>arm-none-eabi/lib/gcc/arm-none-eabi/X.X.X</em> tool-chain directory and you will find multiple directories. One for each ARM architecture; armv6-m, armv7-ar, armv7-m, thumb, thumb2, etc&hellip;</p>

<p>Add a library include for <em>architecture</em> directory that matches the core that you compiled against and everything will be fine:</p>

<p>Cortex M3 example:
<code>
arm-none-eabi-ld -Map bin/main.axf.map -T src/cortex_M3.ld --library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib/thumb/thumb2 --library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib/thumb  --library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib  --library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/lib/gcc/arm-none-eabi/4.8.3/armv7-m -g   obj/printf_with_malloc.o obj/startup.o --start-group -lgcc -lc --end-group -o bin/main.axf
</code></p>

<p>Cortex M0+ example:
<code>
arm-none-eabi-ld -Map bin/main.axf.map -T src/cortex_M0.ld --library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib/thumb/thumb2 --library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/lib/gcc/arm-none-eabi/4.8.3/armv6-m  --gc-sections --print-gc-sections  obj/printf_with_malloc.o obj/startup.o --start-group -lgcc -lc --end-group -o bin/main.axf
</code></p>

<p><a href="http://en.wikipedia.org/wiki/ARM_Cortex-M#Instruction_sets">ARM Cortex-M instruction sets</a></p>

<table class="wikitable">
<tbody><tr>
<th>ARM<br>
Cortex-M</th>
<th>Thumb</th>
<th>Thumb-2</th>
<th>Hardware<br>
multiply</th>
<th>Hardware<br>
divide</th>
<th>Saturated<br>
math</th>
<th>DSP<br>
extensions</th>
<th>Floating-point</th>
<th>ARM<br>
architecture</th>
<th>Core<br>
architecture</th>
</tr>
<tr>
<td>
<center>Cortex-M0<sup id="cite_ref-M0-TRM_1-2" class="reference"><a href="#cite_note-M0-TRM-1"><span>[</span>1<span>]</span></a></sup></center>
</td>
<td style="background: cyan">
<center>Most</center>
</td>
<td style="background: cyan">
<center>Subset</center>
</td>
<td style="background: yellow">
<center>1 or 32 cycle</center>
</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td>
<center>ARMv6-M<sup id="cite_ref-ARMv6-M-Manual_6-8" class="reference"><a href="#cite_note-ARMv6-M-Manual-6"><span>[</span>6<span>]</span></a></sup></center>
</td>
<td><a href="http://sushihangover.github.io/wiki/Von_Neumann_architecture" title="Von Neumann architecture">Von Neumann</a></td>
</tr>
<tr>
<td>
<center>Cortex-M0+<sup id="cite_ref-M0.2B-TRM_2-2" class="reference"><a href="#cite_note-M0.2B-TRM-2"><span>[</span>2<span>]</span></a></sup></center>
</td>
<td style="background: cyan">
<center>Most</center>
</td>
<td style="background: cyan">
<center>Subset</center>
</td>
<td style="background: yellow">
<center>1 or 32 cycle</center>
</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td>
<center>ARMv6-M<sup id="cite_ref-ARMv6-M-Manual_6-9" class="reference"><a href="#cite_note-ARMv6-M-Manual-6"><span>[</span>6<span>]</span></a></sup></center>
</td>
<td><a href="http://sushihangover.github.io/wiki/Von_Neumann_architecture" title="Von Neumann architecture">Von Neumann</a></td>
</tr>
<tr>
<td>
<center>Cortex-M1<sup id="cite_ref-M1-TRM_3-2" class="reference"><a href="#cite_note-M1-TRM-3"><span>[</span>3<span>]</span></a></sup></center>
</td>
<td style="background: cyan">
<center>Most</center>
</td>
<td style="background: cyan">
<center>Subset</center>
</td>
<td style="background: yellow">
<center>3 or 33 cycle</center>
</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td>
<center>ARMv6-M<sup id="cite_ref-ARMv6-M-Manual_6-10" class="reference"><a href="#cite_note-ARMv6-M-Manual-6"><span>[</span>6<span>]</span></a></sup></center>
</td>
<td><a href="http://sushihangover.github.io/wiki/Von_Neumann_architecture" title="Von Neumann architecture">Von Neumann</a></td>
</tr>
<tr>
<td>
<center>Cortex-M3<sup id="cite_ref-M3-TRM_4-2" class="reference"><a href="#cite_note-M3-TRM-4"><span>[</span>4<span>]</span></a></sup></center>
</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Entire</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Entire</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">1 cycle</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Yes</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Yes</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">No</td>
<td>
<center>ARMv7-M<sup id="cite_ref-ARMv7-M-Manual_7-9" class="reference"><a href="#cite_note-ARMv7-M-Manual-7"><span>[</span>7<span>]</span></a></sup></center>
</td>
<td><a href="http://sushihangover.github.io/wiki/Harvard_architecture" title="Harvard architecture">Harvard</a></td>
</tr>
<tr>
<td>
<center>Cortex-M4<sup id="cite_ref-M4-TRM_5-2" class="reference"><a href="#cite_note-M4-TRM-5"><span>[</span>5<span>]</span></a></sup></center>
</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Entire</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Entire</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">1 cycle</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Yes</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Yes</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Yes</td>
<td style="background: yellow">
<center>Optional</center>
</td>
<td>
<center>ARMv7E-M<sup id="cite_ref-ARMv7-M-Manual_7-10" class="reference"><a href="#cite_note-ARMv7-M-Manual-7"><span>[</span>7<span>]</span></a></sup></center>
</td>
<td><a href="http://sushihangover.github.io/wiki/Harvard_architecture" title="Harvard architecture">Harvard</a></td>
</tr>
</tbody></table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM Cortex-M3 Bare-metal With NEWLIB]]></title>
    <link href="http://sushihangover.github.io/arm-cortex-m3-bare-metal-with-newlib"/>
    <updated>2014-03-04T18:18:56-08:00</updated>
    <id>http://sushihangover.github.io/arm-cortex-m3-bare-metal-with-newlib</id>
    <content type="html"><![CDATA[<p>I am working on a custom NEWLIB but first I wanted to make sure that <a href="https://sourceware.org/newlib/">NEWLIB</a> compiled for ARM-NONE-EABI works out of the box with my ARM bare-metal <a href="http://llvm.org">Clang/LLVM</a> build and Qemu.</p>

<p>Lets start with a simple main() that includes printf, puts and malloc. The first test is related to malloc, as if your linker script is not setting up your heap properly and providing the heap &ldquo;end&rdquo; address as defined in NEWLIB then not much else is going to work (i.e. printf uses malloc). If malloc works, then lets so some printfs including one with a random string. After that lets keep increasing the size of our mallocs till we run out of heap space.</p>

<p>{% codeblock lang:c %}</p>

<h1>include &lt;stdio.h>      /<em> printf, scanf, NULL </em>/</h1>

<h1>include &lt;stdlib.h>     /<em> malloc, free, rand </em>/</h1>

<p>int main ()
{
  extern char <em>heap_start; /<em> Defined by the linker from src/cortex_M3.ld </em>/
  extern char </em>heap_end; /<em> Defined by the linker from src/cortex_M3.Ld. </em>/
  int i,n;
  char * buffer;</p>

<p>  i = 43;
  buffer = (char*) malloc (i);
  if (buffer==NULL)
  {</p>

<pre><code> puts ("Malloc failed\n");
 exit (1);
</code></pre>

<p>  }</p>

<p>  printf (&ldquo;Printf string\n&rdquo;);
  for (n=0; n&lt;i; n++)
  {</p>

<pre><code>buffer[n]=rand()%26+'a';
</code></pre>

<p>  }
  buffer[i]=&lsquo;\0&rsquo;;
  printf (&ldquo;Random string: %s\n&rdquo;,buffer);</p>

<p>  i = 32;
  do
  {</p>

<pre><code> buffer = realloc(buffer, i);
 if (buffer == NULL)
 {
    puts("Out of memory!\n");
    exit (1);
 } else {
    printf("%d bytes @ address 0x%X (Low=0x%X:Hi=0x%X)\n",
       i,
       (unsigned int)buffer,
       (unsigned int)&amp;_heap_start,
       (unsigned int)&amp;_heap_end
   );
   i = i + 32;
 }
</code></pre>

<p>  } while (buffer != NULL);</p>

<p>  exit(0); /<em> cause qemu to exit </em>/
  return 0;
}
{% endcodeblock %}</p>

<p>Easy enough, so lets create a linker script that is geared for a Cortex-M3, the main section to pay attention to in this example is <strong>.heap</strong>:
{% codeblock lang:bash %}
OUTPUT_FORMAT (&ldquo;elf32-littlearm&rdquo;, &ldquo;elf32-bigarm&rdquo;, &ldquo;elf32-littlearm&rdquo;)</p>

<p>ENTRY(Reset_Handler)</p>

<p>/<em> Specify the memory areas </em>/
MEMORY
{
  FLASH (rx)      : ORIGIN = 0x00000000, LENGTH = 0x10000 /<em> 64K </em>/
  RAM (xrw)       : ORIGIN = 0x00020000, LENGTH = 0x04000 /<em> 16K </em>/
}</p>

<p>heap_size = 0x800; /<em> 2K </em>/</p>

<p>SECTIONS {</p>

<pre><code>. = ORIGIN(FLASH);

.vectors :
{
    . = ALIGN(4);
    KEEP(*(.vectors)) /* Startup code */
    . = ALIGN(4);
} &gt;FLASH

.text :
{
    . = ALIGN(4);
    _start_text = .;
    *(.text)
    *(.text*)
    *(.rodata)
    *(.rodata*)
    _end_text = .;
} &gt;FLASH

    .ARM.extab : 
    {
            *(.ARM.extab* .gnu.linkonce.armextab.*)
    } &gt; FLASH

    __exidx_start = .;
    .ARM.exidx :
    {
            *(.ARM.exidx* .gnu.linkonce.armexidx.*)
    } &gt; FLASH
    __exidx_end = .;

_end_text = .;

.data : AT (_end_text)
{
    _start_data = .;
    *(.data)
    *(.data*) 
    . = ALIGN(4);
    _end_data = .;
} &gt;RAM 

.bss :
{
     . = ALIGN(4);
    _start_bss = .;
    *(.bss)
    *(.bss*)
    *(COMMON)
    . = ALIGN(4);
    _end_bss = .;
} &gt;RAM

. = ALIGN(4);
.heap :
{
    __end__ = .;
    /* _heap_start = .; */
    /* "end" is used by newlib's syscalls!!! */
    PROVIDE(end = .);
    PROVIDE(_heap_start = end );
    . = . + heap_size;
    PROVIDE(_heap_end = .);
} &gt;RAM

.ARM.attributes 0 : { *(.ARM.attributes) }

.stack_dummy (COPY):
{
    _end_stack = .;
    *(.stack*)
} &gt; RAM

/* Set stack top to end of RAM, and stack limit move down by
 * size of stack_dummy section */
_start_stack = ORIGIN(RAM) + LENGTH(RAM);
_size_stack = _start_stack - SIZEOF(.stack_dummy);
PROVIDE(__stack = _start_stack);

/* Check if data + heap + stack exceeds RAM limit */
ASSERT(_size_stack &gt;= _heap_end, "region RAM overflowed with stack")
</code></pre>

<p>}
_end = .;
{% endcodeblock %}</p>

<p>Ok, now that we have a linker script that defines our stack and heap properly, lets reuse our startup.c routine for the Cortex-M cores and compile it all with CLang/LLVM and link it with arm-none-eabi-ld:</p>

<p>{% codeblock lang:bash %}
clang -g -nostdlib -ffreestanding  -O0  -target arm-none-eabi -mcpu=cortex-m3  -mfloat-abi=soft -mthumb -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/arm-none-eabi/include  -o obj/printf_with_malloc.o -c src/printf_with_malloc.c
clang -g -nostdlib -ffreestanding  -O0  -target arm-none-eabi -mcpu=cortex-m3  -mfloat-abi=soft -mthumb -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/arm-none-eabi/include  -o obj/startup.o -c src/startup.c
arm-none-eabi-ld -Map bin/main.axf.map -T src/cortex_M3.ld &mdash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib/thumb/thumb2 &mdash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib/thumb  &mdash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib  &mdash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/lib/gcc/arm-none-eabi/4.8.3/thumb -g   obj/printf_with_malloc.o obj/startup.o &mdash;start-group -lgcc -lc &mdash;end-group -o bin/main.axf
{% endcodeblock %}</p>

<p>And now we can run a simulation of it with QEMU:</p>

<p>{% codeblock lang:bash %}
qemu-system-arm -cpu cortex-m3  -semihosting -nographic -kernel  bin/main.axf
Puts string
Printf string
Random string: lvqdyoqykfdbxnqdquhydjaeebzqmtblcabwgmscrno
32 bytes @ address 0x209C0 (Low=0x209B4:Hi=0x211B4)
64 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
96 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
128 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
160 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
192 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
224 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
256 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
288 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
320 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
352 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
384 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
416 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
448 bytes @ address 0x20DF8 (Low=0x209B4:Hi=0x211B4)
Out of memory!
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
