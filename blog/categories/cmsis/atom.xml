<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cmsis | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/cmsis/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2015-08-03T13:15:21-07:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[RobertN]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cortex M0 & M3 Sys Tick: Polling Vs. Interrupt Driven]]></title>
    <link href="http://sushihangover.github.io/cortex-m-systick-polling-vs-interrupts/"/>
    <updated>2014-03-09T19:24:34-07:00</updated>
    <id>http://sushihangover.github.io/cortex-m-systick-polling-vs-interrupts</id>
    <content type="html"><![CDATA[<p><a href="/images/ARM_CortexM_CMSIS_large.png">{% img left /images/ARM_CortexM_CMSIS_small.png &ldquo;CMSIS Version 3 Block Diagram (Source: Arm.com)&rdquo; %}</a>
This time around, lets use the CMSIS abstraction layer to access the SysTick core peripheral.</p>

<p>This peripheral can be used to provide the core timer to an embedded RTOS kernel, such as FreeRTOS, or to provide application timing events to know when to read some attached sensors or such. In the most basic form, it provides a pollable countdown value. This value is decreased from a user settable value (<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0179b/ar01s02s08.html">Reload Value</a>) on every clock tick. If it configured as an interrupt, the function assigned activates every n+1 clock ticks.</p>

<p>I used Clang/LLVM to compile a simple app that shows you how to set the reload value, read (poll) the internal SysTick value or enable it as an interrupt.</p>

<p>The semihosting output of this app (via QEMU):
{% codeblock lang:bash %}
qemu-system-arm -M lm3s811evb -cpu cortex-m3 -semihosting -kernel  bin/main.axf
SysTick should not be active yet&hellip;
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
&hellip;Current value: 0
Enable SysTick and lets poll it&hellip;
&hellip;Current value: 6913
&hellip;Current value: 2825
&hellip;Current value: 2450
&hellip;Current value: 2138
&hellip;Current value: 1825
&hellip;Current value: 1525
&hellip;Current value: 1225
&hellip;Current value: 913
&hellip;Current value: 613
&hellip;Current value: 313
Enable SysTick Interrupts and watch local var get incremented&hellip;
&hellip;myTicks = 1; SysTick->VAL = 0
&hellip;myTicks = 2; SysTick->VAL = 3425
&hellip;myTicks = 3; SysTick->VAL = 8725
&hellip;myTicks = 4; SysTick->VAL = 2938
&hellip;myTicks = 5; SysTick->VAL = 8113
&hellip;myTicks = 6; SysTick->VAL = 2550
&hellip;myTicks = 7; SysTick->VAL = 7725
&hellip;myTicks = 8; SysTick->VAL = 2938
&hellip;myTicks = 9; SysTick->VAL = 8125
&hellip;myTicks = 10; SysTick->VAL = 2563
&hellip;myTicks = 11; SysTick->VAL = 8100
&hellip;myTicks = 12; SysTick->VAL = 3038
{% endcodeblock %}</p>

<p>{% codeblock lang:c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &ldquo;CortexM3_xx.h&rdquo;</h1>

<h1>include &lt;core_cm3.h></h1>

<h1>include &lt;stdint.h></h1>

<h1>include &ldquo;svc.h&rdquo;</h1>

<p>volatile uint32_t myTicks;</p>

<p>void SysTick_Handler(void) {
  myTicks++;
  printf(&ldquo;&hellip;myTicks = %lu; SysTick->VAL = %lu\n&rdquo;, myTicks, SysTick->VAL);
}</p>

<p>int main(void) {
    printf(&ldquo;SysTick should not be active yet&hellip;\n&rdquo;);
    for (int x=0; x&lt;10; x++) {
        printf(&ldquo;&hellip;Current value: %lu\n&rdquo;, SysTick->VAL);
    }
    printf(&ldquo;Enable SysTick and lets poll it&hellip;\n&rdquo;);</p>

<pre><code>volatile uint32_t clock = 10000;
SysTick-&gt;LOAD = clock - 1;
/*
    * SysTick_CTRL_CLKSOURCE_Msk : Use core's clock
    * SysTick_CTRL_ENABLE_Msk    : Enable SysTick
    * SysTick_CTRL_TICKINT_Msk   : Active the SysTick interrupt on the NVIC
*/ 
SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
for (int x=0; x&lt;10; x++) {
    printf("...Current value: %lu\n", SysTick-&gt;VAL);
}

printf("Enable SysTick Interrupts and watch local var get incremented...\n");
myTicks = 0;
SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk |  SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk;

while(myTicks &lt;= 10) {
    asm("nop"); // Do nothing till SysTick_Handler been been called at least 10 times
}
exit(0);
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Llvm, Cmsis Dsp And Cortex M3 &Amp; M0]]></title>
    <link href="http://sushihangover.github.io/llvm-cmsis-dsp-and-cortex-m3-and-m0/"/>
    <updated>2014-03-05T22:34:20-08:00</updated>
    <id>http://sushihangover.github.io/llvm-cmsis-dsp-and-cortex-m3-and-m0</id>
    <content type="html"><![CDATA[<p><a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">{% img left /images/cmsis-version-3-block-diagram.png  &ldquo;CMSIS Version 3 Block Diagram (Source: Arm.com)&rdquo; %}</a> I added ARM&rsquo;s CMSIS 3.01 to my LLVM project and wanted to test out the pre-compiled DSP libraries that are supplied.</p>

<p>I borrowed one of the cos/sin examples and added some semihosting <em>printf</em>s using NEWLIB and cleaned up the code a bit.</p>

<blockquote><p><a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php?tab=Download+CMSIS">CMSIS-DSP</a>: DSP Library Collection with over 60 Functions for various data types: fix-point (fractional q7, q15, q31) and single precision floating-point (32-bit). The library is available for Cortex-M0, Cortex-M3, and Cortex-M4. The Cortex-M4 implementation is optimized for the SIMD instruction set.</p></blockquote>

<p>Updating my Makefile to include the correct CMSIS libraries (<em>arm_cortexM3l_math</em>) for the ld and the currect headers for Clang/LLVM and the result <em>works great</em> for Cortex-M3. I copied the project over and mod&rsquo;d the Makefile so it picks up the correct Cortex-M0 lib (<em>arm_cortexM0l_math</em>) and everything looks on this core also.</p>

<p>Clang/LLVM compile and link:
{% codeblock lang:bash %}
clang -Os  -nostdlib -ffreestanding   -target arm-none-eabi  -mcpu=cortex-m0   -mfloat-abi=soft  -mthumb  -DARM_MATH_CM3 -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/CMSIS/Include   -o obj/arm_sin_cos_example_f32.o -c src/arm_sin_cos_example_f32.c
clang -Os  -nostdlib -ffreestanding   -target arm-none-eabi  -mcpu=cortex-m0   -mfloat-abi=soft  -mthumb  -DARM_MATH_CM3 -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/arm-none-eabi/include -I/Users/administrator/Code/llvm_superproject/install/arm-none-eabi/CMSIS/Include   -o obj/startup.o -c src/startup.c
arm-none-eabi-ld -nostartfiles   -nostdlib -nostartupfiles  &ndash;gc-sections  &ndash;print-gc-sections  -Map bin/main.axf.map  -T src/cortex_M0.ld  &ndash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/newlib-syscalls/arm-none-eabi/lib/thumb/thumb2 &ndash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/lib/gcc/arm-none-eabi/4.8.3/armv7-m &ndash;library-path /Users/administrator/Code/llvm_superproject/install/arm-none-eabi/CMSIS/LIB/GCC    obj/arm_sin_cos_example_f32.o obj/startup.o &ndash;start-group &ndash;library=gcc &ndash;library=c &ndash;library=m &ndash;library=arm_cortexM0l_math &ndash;end-group -o bin/main.axf
{% endcodeblock %}</p>

<p>Sample semihousting output from a Cortex-M3:
{% codeblock lang:bash %}
qemu-system-arm -cpu cortex-m3  -semihosting -nographic -kernel  bin/main.axf
Starting Test&hellip;
Cos -1.244917 = 0.320142
Sin -1.244917 = -0.947370
Cos squared 0.320142 = 0.102491
Sin squared -0.947370 = 0.897509
Add 0.102491 and 0.897509 = 1.000000
Cos -4.793534 = 0.081056
Sin -4.793534 = 0.996710
Cos squared 0.081056 = 0.006570
Sin squared 0.996710 = 0.993430
Add 0.006570 and 0.993430 = 1.000000
&hellip;
&hellip;
Cos 1.985805 = -0.403198
Sin 1.985805 = 0.915113
Cos squared -0.403198 = 0.162568
Sin squared 0.915113 = 0.837431
Add 0.162568 and 0.837431 = 1.000000
Ending Test&hellip;
{% endcodeblock %}</p>

<p>{% codeblock lang:c <a href="https://github.com/sushihangover/llvm_baremetal">https://github.com/sushihangover/llvm_baremetal</a> %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;math.h></h1>

<h1>include &ldquo;arm_math.h&rdquo;</h1>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
* Defines each of the tests performed
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- </em>/</p>

<h1>define MAX_BLOCKSIZE   32</h1>

<h1>define DELTA           (0.000001f)</h1>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
* Test input data for Floating point sin_cos example for 32-blockSize
* Generated by the MATLAB randn() function
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- </em>/</p>

<p>const float32_t testInput_f32[MAX_BLOCKSIZE] =<br/>
{  <br/>
 -1.244916875853235400, -4.793533929171324800,  0.360705030233248850,
  0.827929644170887320, -3.299532218312426900,  3.427441903227623800, <br/>
  3.422401784294607700, -0.108308165334010680,  0.941943896490312180,
  0.502609575000365850, -0.537345278736373500,  2.088817392965764500,
 -1.693168684143455700,  6.283185307179590700, -0.392545884746175080,
  0.327893095115825040,  3.070147440456292300,  0.170611405884662230,
 -0.275275082396073010, -2.395492805446796300,  0.847311163536506600,
 -3.845517018083148800,  2.055818378415868300,  4.672594161978930800,
 -1.990923030266425800,  2.469305197656249500,  3.609002606064021000,
 -4.586736582331667500, -4.147080139136136300,  1.643756718868359500,
 -1.150866392366494800,  1.985805026477433800
};</p>

<p>const float32_t testRefOutput_f32 = 1.000000000;</p>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
* Declare Global variables<br/>
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- </em>/
uint32_t blockSize = 32;
float32_t  testOutput;<br/>
float32_t  cosOutput;<br/>
float32_t  sinOutput;<br/>
float32_t  cosSquareOutput;<br/>
float32_t  sinSquareOutput;</p>

<p>/<em> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
* Max magnitude FFT Bin test
* &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- </em>/</p>

<p>arm_status status;</p>

<p>int32_t main(void)
{
   float32_t diff;
   uint32_t i;</p>

<p>   printf(&ldquo;Starting Test&hellip;\n&rdquo;);
   for (i=0; i &lt; blockSize; i++)
   {
      cosOutput = arm_cos_f32(testInput_f32[i]);
      printf(&ldquo;Cos %f = %f\n&rdquo;, testInput_f32[i], cosOutput);</p>

<pre><code>  sinOutput = arm_sin_f32(testInput_f32[i]); 
  printf("Sin %f = %f\n", testInput_f32[i], sinOutput);

  arm_mult_f32(&amp;cosOutput, &amp;cosOutput, &amp;cosSquareOutput, 1); 
  printf("Cos squared %f = %f\n", cosOutput, cosSquareOutput);

  arm_mult_f32(&amp;sinOutput, &amp;sinOutput, &amp;sinSquareOutput, 1); 
  printf("Sin squared %f = %f\n", sinOutput, sinSquareOutput);

  arm_add_f32(&amp;cosSquareOutput, &amp;sinSquareOutput, &amp;testOutput, 1);
  printf("Add %f and %f = %f\n", cosSquareOutput, sinSquareOutput, testOutput);

  /* absolute value of difference between ref and test */ 
  diff = fabsf(testRefOutput_f32 - testOutput); 
  /* Comparison of sin_cos value with reference */ 
  if (diff &gt; DELTA) 
  { 
     printf("Diff failure %f\n", diff);
     exit(EXIT_FAILURE); /* just for QEMU testing */
     while(1); 
  } 
</code></pre>

<p>   }
   printf(&ldquo;Ending Test&hellip;\n&rdquo;);
   exit(EXIT_SUCCESS); /<em> just for QEMU testing </em>/
   while(1); /<em> main function does not return </em>/
}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
