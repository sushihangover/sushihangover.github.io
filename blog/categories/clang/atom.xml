<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CLANG | SushiHangover]]></title>
  <link href="http://sushihangover.github.io/blog/categories/clang/atom.xml" rel="self"/>
  <link href="http://sushihangover.github.io/"/>
  <updated>2014-02-23T05:14:34-08:00</updated>
  <id>http://sushihangover.github.io/</id>
  <author>
    <name><![CDATA[Robert N.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LLVM and the ARM ELF .ARM.exidx* Section]]></title>
    <link href="http://sushihangover.github.io/llvm-and-the-arm-elf-arm-dot-exidx-star-section"/>
    <updated>2014-02-23T06:39:45-08:00</updated>
    <id>http://sushihangover.github.io/llvm-and-the-arm-elf-arm-dot-exidx-star-section</id>
    <content type="html"><![CDATA[<p>In my last <a href="http://sushihangover.github.io/arm-bare-metal-comparing-llvm-to-arm-gcc/">post</a> I did a very basic comparsion of ARM code generation between LLVM and GCC compilers and testing the AXF in Qemu. The stand out difference was LLVM produced a *.ARM.exidx** section in the AXF/ELF while arm-gcc did not. The code is very simple, one .s and one .c file, no .cpp/.h involved.</p>

<p>So what is a <em>.ARM.exidx</em> section?</p>

<p>ARM ELF manual show this under the special sections chapter:</p>

<table>
<thead>
<tr>
<th></th>
<th> Name </th>
<th>￼Type </th>
<th>￼Attributes </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> ARM.exidx </td>
<td>￼ SHT_ARM_EXIDX </td>
<td> SHF_ALLOC + SHF_LINK_ORDER </td>
<td> </td>
</tr>
</tbody>
</table>


<p>_</p>

<blockquote><p>Names beginning .ARM.exidx name sections containing index entries for section unwinding. Names beginning .ARM.extab name sections containing exception unwinding information. See [EHABI] for details.</p></blockquote>

<p>Table 4_4 from that manual shows the Processor specific section types and our attribute is:</p>

<table>
<thead>
<tr>
<th></th>
<th> Name </th>
<th> Value </th>
<th> Comment </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> &ldquo;SHT_ARM_EXIDX&rdquo; </td>
<td> 0x70000001 </td>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>


<p>_</p>

<p>So the question remains, what is in the section and what is being created? Lets dump HelloWorldSimple.o and only look at that section:
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Relocation section &lsquo;.rel.ARM.exidx&rsquo; at offset 0x580 contains 2 entries:
</span><span class='line'> Offset     Info    Type            Sym.Value  Sym. Name
</span><span class='line'>00000000  00000b2a R_ARM_PREL31      00000000   .text
</span><span class='line'>00000008  00000b2a R_ARM_PREL31      00000000   .text
</span><span class='line'>Unwind table index &lsquo;.ARM.exidx&rsquo; at offset 0xcc contains 2 entries:
</span><span class='line'>0x0 &lt;print_uart0>: 0x1 [cantunwind]
</span><span class='line'>0x54 &lt;c_entry>: 0x1 [cantunwind]</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>So it added both function calls to the table, but are marked <em>cantunwind</em>, which makes sense, but since nothing in the section can be unwound, why include the section? Using gc-sections during linking does not remove it as it has references to functions that are being used&hellip;</p>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Relocation section &lsquo;.rel.ARM.exidx&rsquo; at offset 0x5a4 contains 4 entries:
</span><span class='line'> Offset     Info    Type            Sym.Value  Sym. Name
</span><span class='line'>00000000  00000b2a R_ARM_PREL31      00000000   .text
</span><span class='line'>00000000  00001600 R_ARM_NONE        00000000   &lt;strong>aeabi_unwind_cpp_pr0
</span><span class='line'>00000008  00000b2a R_ARM_PREL31      00000000   .text
</span><span class='line'>00000008  00001600 R_ARM_NONE        00000000   &lt;/strong>aeabi_unwind_cpp_pr0
</span><span class='line'>Unwind table index &lsquo;.ARM.exidx&rsquo; at offset 0xcc contains 2 entries:
</span><span class='line'>0x0 &lt;print_uart0>: 0x8001b0b0
</span><span class='line'>  Compact model index: 0
</span><span class='line'>  0x01      vsp = vsp + 8
</span><span class='line'>  0xb0      finish
</span><span class='line'>  0xb0      finish
</span><span class='line'>0x54 &lt;c_entry>: 0x809b8480
</span><span class='line'>  Compact model index: 0
</span><span class='line'>  0x9b      vsp = r11
</span><span class='line'>  0x84 0x80 pop {r11, r14}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Additional Reading: <a href="https://sourceware.org/ml/binutils/2009-05/msg00048.html">ARM unwind table linker processing</a>; this concerns a patch to bintutils/ld:</p>

<blockquote><p>The patch below implements linker processing of ARM unwinding tables
(SHT_ARM_EXIDX).</p>

<p>ARM exception index tables only define the start address of each region. This
means that code with no unwinding information is effectively covered by the
preceding unwinding table entry.</p>

<p>For normal exceptions that doesn&rsquo;t matter so much &ndash; the user should ensure
that any code they throw exceptions through has proper unwinding information.</p></blockquote>

<p>Just as a quick check, I grep&rsquo;d some source and the *.ARM.exidx** section is generated by the ARMELFStreamer:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;a href="http://llvm.org/docs/doxygen/html/ARMELFStreamer_8cpp_source.html">http://llvm.org/docs/doxygen/html/ARMELFStreamer_8cpp_source.html&lt;/a>
</span><span class='line'>00274 inline void ARMELFStreamer::SwitchToExIdxSection(const MCSymbol &amp;FnStart) {
</span><span class='line'>00275   SwitchToEHSection(&ldquo;.ARM.exidx&rdquo;,
</span><span class='line'>00276                     ELF::SHT_ARM_EXIDX,
</span><span class='line'>00277                     ELF::SHF_ALLOC | ELF::SHF_LINK_ORDER,
</span><span class='line'>00278                     SectionKind::getDataRel(),
</span><span class='line'>00279                     FnStart);
</span><span class='line'>00280 }</span></code></pre></td></tr></table></div></figure></notextile></div>
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;a href="http://llvm.org/docs/doxygen/html/Support_2ELF_8h_source.html01145">http://llvm.org/docs/doxygen/html/Support_2ELF_8h_source.html01145&lt;/a>   // Fixme: All this is duplicated in MCSectionELF. Why??
</span><span class='line'>01146   // Exception Index table
</span><span class='line'>01147   SHT_ARM_EXIDX           = 0x70000001U,</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM Bare Metal Hello World: Comparing LLVM & ARM-GCC]]></title>
    <link href="http://sushihangover.github.io/arm-bare-metal-comparing-llvm-to-arm-gcc"/>
    <updated>2014-02-22T20:43:28-08:00</updated>
    <id>http://sushihangover.github.io/arm-bare-metal-comparing-llvm-to-arm-gcc</id>
    <content type="html"><![CDATA[<p>With the ever maturing and stable ARM backend of LLVM it is hard to find information using it vs. the well known ARM-GCC release.</p>

<p>So lets start with the most simple HelloWorld example and compare LLVM and <a href="https://launchpad.net/gcc-arm-embedded">ARM-GCC</a>.</p>

<p><a href="http://balau82.wordpress.com/2010/02/28/hello-world-for-bare-metal-arm-using-qemu/">Balau&rsquo;s post</a> is a popular one showing an ARM bare metal Hello World and test using QEMU, so lets start with that one. First, lets reproduce the compile/link steps to make sure it works:</p>

<p><code>
arm-none-eabi-as -mcpu=arm926ej-s src/startup.s -o obj/startup.o
arm-none-eabi-gcc -c -mcpu=arm926ej-s -O0 src/HelloWorldSimple.c -o obj/HelloWorldSimple.o
arm-none-eabi-ld -T src/HelloWorldSimple.ld obj/HelloWorldSimple.o obj/startup.o -o bin/HelloWorldSimple.axf_gcc
arm-none-eabi-size bin/HelloWorldSimple.axf_gcc
qemu-system-arm -M versatilepb -m 128M -nographic -kernel bin/HelloWorldSimple.axf_gcc
Hello world!
QEMU: Terminated
</code>
Works just fine, so lets reproduce that using   my <a href="https://github.com/sushihangover/llvm_baremetal">LLVM bare metal build</a>. All the compiler options are being shown even though some are defaulted in my build of LLVM so you can see everything it is required to get the LLVM bitcode conversion to produce a valid object file for our ARM target (I&rsquo;m using the Clang driver, but you can use LLVM and pipe bitcode through the various tools so you can deeply control the optimization phase):
<code>
clang -c -target arm-none-eabi -mcpu=arm926ej-s -O0 -mfloat-abi=soft -g startup.s -o startup.o
clang -c -target arm-none-eabi -mcpu=arm926ej-s -O0 -mfloat-abi=soft -g HelloWorldSimple.c -o main.o
arm-none-eabi-ld -T HelloWorldSimple.ld main.o startup.o -o main.axf_llvm
qemu-system-arm -M versatilepb -m 128M -nographic -kernel main.axf_llvm
Hello world!
QEMU: Terminated
</code>
* target : Option providing the triple that you are &lsquo;targeting&rsquo;
* mpcu : Option provding the ARM core that will be flashed
* mfloat-abi : Soft or Hard depending upon if your ARM core has an FPU implementation on it. Cores that can support an FPU does not mean your vendor&rsquo;s core has one, comes down to features/price of the core.</p>

<h6>Note: In both, I am turning off the optimizers via the compile drivers.</h6>

<p>Lets look at the size of the AXF (ARM Executable Format) produced by:</p>

<p>```
   text    data     bss     dec     hex filename</p>

<pre><code>140       0       0     140      8c bin/HelloWorldSimple.axf_gcc
</code></pre>

<p>   text    data     bss     dec     hex filename</p>

<pre><code>150       0       0     150      96 bin/HelloWorldSimple.axf
</code></pre>

<p>```
There is a 10 byte difference, interesting&hellip; lets look at that a little more:</p>

<table>
<thead>
<tr>
<th></th>
<th> llvm </th>
<th></th>
<th></th>
<th> arm-gcc </th>
<th> </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> section  </td>
<td> size </td>
<td> addr</td>
<td>section </td>
<td>size</td>
<td> addr</td>
</tr>
<tr>
<td></td>
<td>.startup  </td>
<td>16</td>
<td>   65536</td>
<td>.startup </td>
<td> 16 </td>
<td>65536</td>
</tr>
<tr>
<td></td>
<td>.text </td>
<td>             108 </td>
<td>  65552</td>
<td>.text              </td>
<td>104   </td>
<td>65552</td>
</tr>
<tr>
<td></td>
<td>.ARM.exidx</td>
<td>           8 </td>
<td>  65660</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>.rodata   </td>
<td>           4 </td>
<td>  65668</td>
<td>.rodata  </td>
<td>           20  </td>
<td> 65656</td>
</tr>
<tr>
<td></td>
<td>.rodata.str1.1</td>
<td>      14 </td>
<td>  65672</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>.ARM.attributes</td>
<td>     40 </td>
<td>      0</td>
<td>.ARM.attributes </td>
<td>    46 </td>
<td>      0</td>
</tr>
<tr>
<td></td>
<td>.comment       </td>
<td>     19 </td>
<td>      0</td>
<td>.comment  </td>
<td>         112  </td>
<td>     0</td>
</tr>
<tr>
<td></td>
<td>Total          </td>
<td>    209</td>
<td></td>
<td>Total              </td>
<td>298</td>
<td></td>
</tr>
</tbody>
</table>


<h6>Note: I ran strip on the arm-gcc version to remove the empty debug sections that gcc inserts automatically</h6>

<p>The <strong>.startup</strong> are the same size since this code is assembly and no codegen or optimization will happen there.</p>

<p>It is interesting that LLVM inserts a <strong>.ARM.exidx</strong> section even though this is <em>only</em> .c code. I&rsquo;ll have to look at LLVM to see if <em>-funwind-tables</em> and/or <em>-fexceptions</em> are defaulted to on, but I disassemble it below so we can look at that as that is 8 bytes and accounts for the size difference in this really basic example.</p>

<blockquote><p>.ARM.exidx is the section containing information for unwinding the stack</p></blockquote>

<h6>Note: Understanding the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044e/IHI0044E_aaelf.pdf">ARM ELF format</a> is not really required to do bare metal programming, but, understanding how your code is allocated and loaded can maek a world of differences when you are writting linker definitions files for different cores, so send a few minutes and read the 46 pages :&ndash;)</h6>

<p>First the gcc disassembly so we can compare the LLVM version to it:
<code>
bin/HelloWorldSimple.axf_gcc:     file format elf32-littlearm
Disassembly of section .startup:
00010000 &lt;_Reset&gt;:
   10000:   e59fd004    ldr sp, [pc, #4]    ; 1000c &lt;_Reset+0xc&gt;
   10004:   eb000015    bl  10060 &lt;c_entry&gt;
   10008:   eafffffe    b   10008 &lt;_Reset+0x8&gt;
   1000c:   00011090    .word   0x00011090
Disassembly of section .text:
00010010 &lt;print_uart0&gt;:
   10010:   e52db004    push    {fp}        ; (str fp, [sp, #-4]!)
   10014:   e28db000    add fp, sp, #0
   10018:   e24dd00c    sub sp, sp, #12
   1001c:   e50b0008    str r0, [fp, #-8]
   10020:   ea000006    b   10040 &lt;print_uart0+0x30&gt;
   10024:   e59f3030    ldr r3, [pc, #48]   ; 1005c &lt;print_uart0+0x4c&gt;
   10028:   e51b2008    ldr r2, [fp, #-8]
   1002c:   e5d22000    ldrb    r2, [r2]
   10030:   e5832000    str r2, [r3]
   10034:   e51b3008    ldr r3, [fp, #-8]
   10038:   e2833001    add r3, r3, #1
   1003c:   e50b3008    str r3, [fp, #-8]
   10040:   e51b3008    ldr r3, [fp, #-8]
   10044:   e5d33000    ldrb    r3, [r3]
   10048:   e3530000    cmp r3, #0
   1004c:   1afffff4    bne 10024 &lt;print_uart0+0x14&gt;
   10050:   e24bd000    sub sp, fp, #0
   10054:   e49db004    pop {fp}        ; (ldr fp, [sp], #4)
   10058:   e12fff1e    bx  lr
   1005c:   101f1000    .word   0x101f1000
00010060 &lt;c_entry&gt;:
   10060:   e92d4800    push    {fp, lr}
   10064:   e28db004    add fp, sp, #4
   10068:   e59f0004    ldr r0, [pc, #4]    ; 10074 &lt;c_entry+0x14&gt;
   1006c:   ebffffe7    bl  10010 &lt;print_uart0&gt;
   10070:   e8bd8800    pop {fp, pc}
   10074:   0001007c    .word   0x0001007c
</code>
Now the LLVM version:
<code>
bin/HelloWorldSimple.axf:     file format elf32-littlearm
Disassembly of section .startup:
00010000 &lt;_Reset&gt;:
   10000:   e59fd004    ldr sp, [pc, #4]    ; 1000c &lt;_Reset+0xc&gt;
   10004:   eb000016    bl  10064 &lt;c_entry&gt;
   10008:   eafffffe    b   10008 &lt;_Reset+0x8&gt;
   1000c:   00011098    .word   0x00011098
Disassembly of section .text:
00010010 &lt;print_uart0&gt;:
   10010:   e24dd008    sub sp, sp, #8
   10014:   e1a01000    mov r1, r0
   10018:   e58d0004    str r0, [sp, #4]
   1001c:   e58d1000    str r1, [sp]
   10020:   e59d0004    ldr r0, [sp, #4]
   10024:   e5d00000    ldrb    r0, [r0]
   10028:   e3500000    cmp r0, #0
   1002c:   0a000009    beq 10058 &lt;print_uart0+0x48&gt;
   10030:   eaffffff    b   10034 &lt;print_uart0+0x24&gt;
   10034:   e59d0004    ldr r0, [sp, #4]
   10038:   e5d00000    ldrb    r0, [r0]
   1003c:   e59f101c    ldr r1, [pc, #28]   ; 10060 &lt;print_uart0+0x50&gt;
   10040:   e5911000    ldr r1, [r1]
   10044:   e5810000    str r0, [r1]
   10048:   e59d0004    ldr r0, [sp, #4]
   1004c:   e2800001    add r0, r0, #1
   10050:   e58d0004    str r0, [sp, #4]
   10054:   eafffff1    b   10020 &lt;print_uart0+0x10&gt;
   10058:   e28dd008    add sp, sp, #8
   1005c:   e12fff1e    bx  lr
   10060:   00010084    .word   0x00010084
00010064 &lt;c_entry&gt;:
   10064:   e92d4800    push    {fp, lr}
   10068:   e1a0b00d    mov fp, sp
   1006c:   e59f0004    ldr r0, [pc, #4]    ; 10078 &lt;c_entry+0x14&gt;
   10070:   ebffffe6    bl  10010 &lt;print_uart0&gt;
   10074:   e8bd8800    pop {fp, pc}
   10078:   00010088    .word   0x00010088
</code>
<a href="/images/llvm-gcc-diff_large.png"><img class="left" src="/images/llvm-gcc-diff_small.png" title="&ldquo;LLVM vs. GCC Hello World ARM Bare Metal&rdquo;" ></a> We can ignore the _Reset section as that is hand coded assembly and the same for both.</p>

<p>The c_entry is interesting as LLVM uses a move to copy the stack register to fp (r11 = frame pointer) which I what I would do, but arm-gcc does an &ldquo;"add&rdquo;&ldquo; to get fp into the sp and does that by adding fp to register #4(?) This is flagged as general variable for gcc&hellip; I am slightly confused by gcc&rsquo;s choice to do that, now that question is when would #4 not contain zero? The rest of this function is the same between the two compilers.</p>

<p>The print_uart0 function is a hack function as it does not implement FIFO/flow-control to an actual UART, but in this case it points to a memory address where the discontinued ARM Versatile PB dev-board does have a UART and QEMU board simulation echos those writes. I am not going to do a line by line comparision of the generated code as for un-optimized code they are both getting the job done, but in slightly different ways in almost the same number of instructions.</p>

<p>So we are able to produce a working bare metal ARM AXF from LLVM and next time, I will spend a little time on compiler optimizations to see how the two code generators/optimizisers compare&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ellcc.org Build Fix for OS-X]]></title>
    <link href="http://sushihangover.github.io/ellcc-dot-org-build-fix-for-os-x"/>
    <updated>2014-02-12T00:00:00-08:00</updated>
    <id>http://sushihangover.github.io/ellcc-dot-org-build-fix-for-os-x</id>
    <content type="html"><![CDATA[<p>In my ARM Bare Metal searches for using Clang/LLVM I stumbled across <a href="http://ellcc.org">The ELLCC Embedded Compiler Collection</a> that provides a one-stop build enviroment for all the LLVM tools for cross-platform compiling.</p>

<p>I&rsquo;m not sure if they are trying to be a <a href="http://yagarto.org">YAGARTO</a> for LLVM vs. GCC. I waiting for a reply to post on their forum to understand the actual code changes to Clang/LLVM that they include (if any). <del>I will update when I hear back.</del> <strong>(Update: Read Rich&rsquo;s <a href="http://ellcc.org/blog/?topic=ellcc-vs-clangllvm-trunk/#post-1571">full reply</a>, it cleared everything up for me)</strong></p>

<p><blockquote><p>ELLCC is really just a weekly repackaging of clang/LLVM with two minor additions.<br/>1. The triples of the form -ellcc- (where OS is linux for now, but will include others eventually) control how include files and libraries are found. You might notice for example that the #include path for ELLCC&hellip;</p><footer><strong>Rich <a href="http://ellcc.org/blog/?topic=ellcc-vs-clangllvm-trunk/#post-1571">http://ellcc.org/blog/?topic=ellcc-vs-clangllvm-trunk/#post-1571</a> What is ELLCC all about</strong></footer></blockquote></p>

<p>But in the mean time I figured I give it a build and include it in my GCC/ARM vs. Clang/LLVM-ARM testing but hit a build error on OS-X. On the linking of QEMU, libintl (GNU&rsquo;s gettext) is not found:</p>

<p><code>
LINK  i386-softmmu/qemu-system-i386
ld: library not found for -lintl
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[1]: *** [qemu-system-i386] Error 1
make: *** [subdir-i386-softmmu] Error 2
</code>
I do have gettext on my system, but it is in my &ldquo;Cellar&rdquo;&ldquo; as I use <a href="http://brew.sh">HomeBrew</a> as my package manager and try not to install anything to &rdquo;/usr/bin" or other systems places that can muck everything up and thus can run parrallels versions of different applications (i.e. If I have to &lsquo;sudo&rsquo; to an open-source software install, it is not going on my system unless they have a serious reason for it and I trust the code from a security viewpoint).</p>

<p>FYI: Brew does not &lsquo;hard&rsquo; link gettext as compiling software outside of the HomeBrew can cause problems:</p>

<p><blockquote><p>brew link gettext<br/>Warning: gettext is keg-only and must be linked with &mdash;force<br/>Note that doing so can interfere with building software.</p></blockquote></p>

<p>So I mod&rsquo;d the &ldquo;ellcc/gnu/build&rdquo; to force brew to link gettext before compiling/linking qemu and unlink it after.</p>

<p>``` bash
svn diff build</p>

<h1>Index: build</h1>

<p>&mdash;&ndash; build   (revision 3780)
+++ build   (working copy)
@@ -69,6 +69,10 @@</p>

<pre><code> ppc-linux-user ppc64-linux-user ppc64abi32-linux-user sparc-linux-user"
</code></pre>

<p> fi
 echo Configuring package qemu for $targets
+if [!  -e <code>which brew</code> ]; then
+   ruby -e &ldquo;$(curl -fsSL <a href="https://raw.github.com/Homebrew/homebrew/go/install">https://raw.github.com/Homebrew/homebrew/go/install</a>)&rdquo;
+fi
+brew link gettext &mdash;force
 qemu_target_list=<code>echo $qemu_target_list | sed -e "s/ /,/g"</code>
 make DIR=src/qemu CC=$cc HCC=$hcc AR=$ar TARGET=$host OS=$os \</p>

<pre><code> targetlist=$qemu_target_list haslibs=$haslibs \
</code></pre>

<p>@@ -76,6 +80,7 @@</p>

<pre><code> qemu.configure || exit 1
</code></pre>

<p> make -C src/qemu || exit 1
+brew unlink gettext</p>

<p> # Finally, install into the target specific bin dir.
 mkdir -p $bindir
```
Everything builds fine after that&hellip;</p>

<p>The entire file is here:
<div><script src='https://gist.github.com/8949755.js'></script>
<noscript><pre><code>#!/bin/sh
# ELLCC GNU tools build script.

# Get the staging directory.
prefix=`cd ..; pwd`

# Figure out the compilers to use.
. ../build-setup $*

echo Configured to $WHY.
echo C compiler: $cc $CFLAGS
echo C++ compiler: $cxx $CXXFLAGS
echo In: gnu-build$builddir

# Configure for GNU tools.
mkdir -p gnu-build$builddir

# Configure for binutils.
# binutils are build to support all targets in the target list.
echo Configuring package binutils for $targets
make DIR=gnu-build$builddir CC=$cc CXX=$cxx AR=$ar TARGET=$host OS=$os \
    targetlist=$targetlist haslibs=$haslibs \
    bindir=$bindir prefix=$prefix build=$build \
    binutils.configure || exit 1

make -C gnu-build$builddir/binutils || exit 1

# Configure for assemblers for all targets.
for t in $targets; do
  echo Configuring the assembler for $t
  make DIR=gnu-build$builddir CC=$cc CXX=$cxx AR=$ar TARGET=$host OS=$os \
      target=$t haslibs=$haslibs \
      bindir=$bindir prefix=$prefix build=$build \
      gas.configure || exit 1

  make -C gnu-build$builddir/binutils/$t || exit 1
done

# Configure for GDB.
# GDB is built to support all GDB targets.
echo Configuring package gdb for $targets
make DIR=gnu-build$builddir CC=$cc CXX=$cxx AR=$ar TARGET=$host OS=$os \
    targetlist=$targetlist haslibs=$haslibs \
    bindir=$bindir prefix=$prefix build=$build \
    gdb.configure || exit 1

make -C gnu-build$builddir/gdb || exit 1

if [ &quot;$host&quot; != &quot;$build&quot; ] ; then
  # The host system is not the build system.
  # Build only  binutils, the assemblers, and gdb.
  # Finally, install into the target specific bin dir.
  mkdir -p $bindir
  make TARGETDIR=$builddir BINDIR=$bindir installcross || exit 1
  exit 0
fi

# Configure for QEMU.
# The QEMU system targets.
qemu_target_list=&quot;i386-softmmu x86_64-softmmu arm-softmmu \
    microblaze-softmmu mips-softmmu mipsel-softmmu \
    ppc-softmmu ppc64-softmmu sparc-softmmu&quot;

if [ `uname` = &quot;Linux&quot; ] ; then
    # The QEMU Linux user space targets.
    qemu_target_list=&quot;$qemu_target_list i386-linux-user \
    x86_64-linux-user arm-linux-user armeb-linux-user \
    microblaze-linux-user mips-linux-user mipsel-linux-user \
    ppc-linux-user ppc64-linux-user ppc64abi32-linux-user sparc-linux-user&quot;
fi
echo Configuring package qemu for $targets
if [!  -e `which brew` ]; then
        ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot;
fi
brew link gettext --force
qemu_target_list=`echo $qemu_target_list | sed -e &quot;s/ /,/g&quot;`
make DIR=src/qemu CC=$cc HCC=$hcc AR=$ar TARGET=$host OS=$os \
    targetlist=$qemu_target_list haslibs=$haslibs \
    bindir=$bindir prefix=$prefix build=$build \
    qemu.configure || exit 1

make -C src/qemu || exit 1
brew unlink gettext

# Finally, install into the target specific bin dir.
mkdir -p $bindir
make TARGETDIR=$builddir BINDIR=$bindir install || exit 1
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS-X LLVM / CLANG Build]]></title>
    <link href="http://sushihangover.github.io/os-x-llvm-slash-clang-build"/>
    <updated>2014-02-11T00:00:00-08:00</updated>
    <id>http://sushihangover.github.io/os-x-llvm-slash-clang-build</id>
    <content type="html"><![CDATA[<p>I wanted to test out some C code that I am writting for a ARM Bare Metal (Embedded) project in QEMU (qemu-system-arm) and normally would just use the <a href="https://launchpad.net/gcc-arm-embedded">GNU Tools for ARM Embedded Processors</a> but I was wondering what the current state of LLVM is for cross-compiling to bare-metal ARM.</p>

<p>Since this is a new area for me and I am having a <strong>dang hard time</strong> finding what is and isn&rsquo;t supported in CLang/LLVM for embedded ARM development, I figured I would compile the latest version and see the difference in code that gets produced between the gcc and Clang compilers.</p>

<p>Thus I needed to latest and greatest Clang/LLVM and did not feel like nurse-maiding a huge git download and long compile session, so I spent a minute and hacked up a really simple script so I could catch up on &ldquo;Game of Thrones&rdquo; ;&ndash;)</p>

<p><div><script src='https://gist.github.com/8946898.js'></script>
<noscript><pre><code>git clone http://llvm.org/git/llvm.git
pushd llvm/tools
git clone http://llvm.org/git/clang.git
popd
pushd llvm/projects
git clone http://llvm.org/git/compiler-rt.git
popd
pushd llvm/projects
git clone http://llvm.org/git/test-suite.git
popd
mkdir llvmbuild
pushd llvmbuild
../llvm/configure --enable-optimized --enable-jit --prefix=/Users/administrator/llvm-install 
make
</code></pre></noscript></div>
</p>

<p>FYI: <a href="http://clang.llvm.org/docs/CrossCompilation.html">Cross-compilation using Clang</a></p>
]]></content>
  </entry>
  
</feed>
